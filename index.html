<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockitect - Mermaid Block Diagram Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Basic layout and utility styles to replace Tailwind */
        :root{
            --bg: #f3f4f6; /* gray-100 */
            --text: #1f2937; /* gray-800 */
            --muted: #6b7280; /* gray-500 */
            --panel-bg: #ffffff;
            --primary: #2563eb; /* blue-600 */
            --primary-600: #1d4ed8;
            --danger: #ef4444;
            --success: #16a34a;
            --purple: #7c3aed;
        }
        html,body,#app{height:100%;}
        body{background:var(--bg);color:var(--text);margin:0}

        .app-root{display:flex;flex-direction:column;height:100vh}
        header.app-header{background:var(--panel-bg);box-shadow:0 1px 3px rgba(0,0,0,0.06);padding:12px 16px;display:flex;justify-content:space-between;align-items:center}
        .header-left{display:flex;align-items:center;gap:12px}
        .header-left h1{font-size:1.25rem;margin:0;font-weight:700}
        input.title-input{padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;outline:none;width:16rem}
        input.title-input:focus{box-shadow:0 0 0 3px rgba(37,99,235,0.12);border-color:var(--primary)}

        .header-actions{display:flex;align-items:center;gap:8px}
        .btn{border:none;padding:8px 12px;border-radius:8px;color:white;font-weight:600;cursor:pointer}
        .btn.secondary{background:#6b7280}
        .btn.primary{background:var(--primary)}
        .btn.ghost{background:transparent;color:var(--text);border:1px solid transparent}
        .btn.danger{background:var(--danger)}
        .btn.purple{background:var(--purple)}
        .btn:disabled{opacity:0.6;cursor:not-allowed}

        main.app-main{display:flex;flex:1;padding:16px;gap:16px;overflow:hidden}
        .panel{background:var(--panel-bg);border-radius:12px;box-shadow:0 6px 18px rgba(15,23,42,0.06);display:flex;flex-direction:column;overflow:hidden}
        .panel .panel-header{padding:8px 12px;border-bottom:1px solid #e5e7eb}
        .panel .panel-body{padding:8px;flex:1;overflow:auto}

        .canvas-panel{flex:1;display:flex;flex-direction:column}
        #canvas-container{position:relative;flex:1;overflow:auto}
        canvas#canvas{position:absolute;top:0;left:0}
        textarea#text-editor{position:absolute;z-index:10;display:none}

        .md-panel{width:33%;min-width:220px;display:flex;flex-direction:column}
        textarea#markdown-output{width:100%;height:100%;padding:8px;border:0;border-radius:6px;background:#f8fafc;font-family:monospace;font-size:0.85rem}

        /* Grid background (kept from original) */
        .grid-bg {
            background-image:
                linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .context-menu {
            display: none;
            position: absolute;
            z-index: 1000;
            background: var(--panel-bg);
            border:1px solid #d1d5db;
            border-radius:8px;
            box-shadow:0 8px 24px rgba(0,0,0,0.08);
            min-width:180px;
            padding:4px 4px;
        }
        .context-menu.show { display:block }
        .context-menu button{background:transparent;border:none;padding:8px 10px;width:100%;text-align:left;cursor:pointer;border-radius:6px}
        .context-menu button:hover{background:#f3f4f6}
    .context-menu .hidden-item{display:none}
        /* Modal Styles */
        .modal-overlay {
            position: fixed;inset:0;background-color:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:2000;padding:16px
        }
        .modal-content{background:var(--panel-bg);padding:16px;border-radius:10px;width:min(720px,100%);box-shadow:0 10px 25px rgba(0,0,0,0.12)}
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        /* Reused UI classes to replace inline styles */
        .panel-title { margin:0; font-size:1rem; font-weight:600; }
        .text-editor { z-index:10; }

        .modal-header-row { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
        .modal-title { font-size:1.125rem; font-weight:700; margin:0 }
        .modal-close { background:transparent; border:none; font-size:1.25rem; cursor:pointer }
        .color-swatches { display:flex; flex-wrap:wrap; gap:8px }
        .modal-footer-right { display:flex; justify-content:flex-end; margin-top:12px }

        .input-label { display:block; font-size:0.9rem; color:var(--muted) }
        .load-footer { display:flex; justify-content:flex-end; align-items:center; margin-top:16px; padding-top:12px; border-top:1px solid #e5e7eb }
        .error-text { color:var(--danger); font-size:0.9rem; margin-top:8px; text-align:right }

        /* Color swatch styles */
        .color-swatch {
            width: 34px;
            height: 34px;
            border-radius: 6px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .color-swatch:hover {
            transform: scale(1.06);
        }
        .color-swatch.selected {
            border-color: #111 !important;
            box-shadow: 0 0 0 2px rgba(17, 24, 39, 0.2);
        }
        .color-swatch.clear {
            background: transparent;
            border-color: #9CA3AF;
            color: #374151;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

    /* Color HUD (small swatches near selected block) */
    .color-hud { position: absolute; display:flex; gap:8px; padding:6px; background: rgba(255,255,255,0.96); border:1px solid #e5e7eb; border-radius:8px; box-shadow:0 8px 20px rgba(15,23,42,0.08); z-index:1500; }
    .color-hud.hidden { display:none }
    .color-hud .sw { width:28px; height:28px; border-radius:6px; border:2px solid transparent; cursor:pointer; box-sizing:border-box; transition: all 0.15s ease; }
    .color-hud .sw:focus { outline:2px solid rgba(0,0,0,0.08) }
    .color-hud .sw:hover { transform: scale(1.06) }
    .color-hud .sw.current { border-color: #111; box-shadow: 0 0 0 1px rgba(17, 24, 39, 0.3); }
    .color-hud .clear-swatch { background: transparent; border-color: #9CA3AF; color: #374151; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; }
    .color-hud .color-swatch-hud { border: 2px solid transparent; }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Minimal Tailwind-like utility fallbacks used in the markup */
        .hidden{display:none!important}
        .flex{display:flex}
        .block{display:block}
        .items-center{align-items:center}
        .justify-between{justify-content:space-between}
        .text-left{text-align:left}
        .text-right{text-align:right}
        .text-center{text-align:center}

        .w-full{width:100%}
        .h-24{height:6rem}
        .h-32{height:8rem}
        .h-48{height:12rem}

        .px-4{padding-left:1rem;padding-right:1rem}
        .py-2{padding-top:0.5rem;padding-bottom:0.5rem}
        .p-2{padding:0.5rem}
        .p-1{padding:0.25rem}
        .p-4{padding:1rem}
        .pt-4{padding-top:1rem}
        .mb-4{margin-bottom:1rem}
        .mt-6{margin-top:1.5rem}
        .mt-2{margin-top:0.5rem}
        .space-y-4 > * + *{margin-top:1rem}
        .space-x-2 > * + *{margin-left:0.5rem}
        .space-x-4 > * + *{margin-left:1rem}

        .border{border:1px solid #e5e7eb}
        .border-t{border-top:1px solid #e5e7eb}
        .border-2{border-width:2px}
        .border-gray-300{border-color:#d1d5db}
        .bg-white{background:#ffffff}
        .bg-gray-50{background:#f9fafb}
        .bg-gray-100{background:#f3f4f6}

        .rounded-md{border-radius:6px}
        .rounded-lg{border-radius:8px}
        .shadow-lg{box-shadow:0 8px 24px rgba(0,0,0,0.08)}

        .text-sm{font-size:0.875rem}
        .text-xl{font-size:1.25rem}
        .font-bold{font-weight:700}
        .font-medium{font-weight:500}
        .font-mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace}
        .font-sans{font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}

        .text-gray-700{color:#374151}
        .text-gray-500{color:#6b7280}
        .text-red-600{color:#dc2626}
        .text-red-500{color:#ef4444}
        .text-white{color:#fff}

        .hover\:bg-gray-100:hover{background:#f3f4f6}
        .hover\:bg-gray-600:hover{background:#4b5563}
        .hover\:bg-blue-700:hover{background:#1d4ed8}
        .hover\:bg-green-700:hover{background:#15803d}
        .hover\:bg-purple-700:hover{background:#6d28d9}
        .hover\:text-gray-800:hover{color:#1f2937}

        .transition{transition:all 0.15s ease}
        .overflow-y-auto{overflow-y:auto}
        .resize-none{resize:none}
        .focus\:outline-none:focus{outline:none}
        
        /* Test button styles */
        .test-button {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            padding: 5px 10px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        /* Arrow mode indicator in header */
        .arrow-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            background: rgba(37,99,235,0.12);
            color: #1d4ed8;
            border: 1px solid rgba(29,78,216,0.12);
        }
        .conn-tooltip {
            position: absolute;
            z-index: 1600;
            background: rgba(17,24,39,0.95);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
            box-shadow: 0 6px 18px rgba(0,0,0,0.18);
        }

    </style>
</head>
<body>
    <div class="app-root" id="app">
        <header class="app-header">
            <div class="header-left">
                <h1>Blockitect</h1>
                <input type="text" id="diagram-title" placeholder="Enter Diagram Title" class="title-input">
            </div>
            <div class="header-actions">
                <button id="load-markdown" class="btn secondary">Load Block Diagram</button>
                <button id="clear-canvas" class="btn danger">Clear Canvas</button>
                <button id="copy-markdown" class="btn primary">Copy Mermaid</button>
                <button id="clear-styles" class="btn purple">Clear styles</button>
                <button id="fit-diagram" class="btn ghost">Fit Diagram</button>
                <button id="arrow-mode" class="btn secondary">🔗 Arrow Mode</button>
                <button id="toggle-ghost-spaces" class="btn ghost">Ghost spaces: On</button>
                <div id="arrow-indicator" class="arrow-indicator hidden">🔗 Arrow Mode</div>
            </div>
        </header>

        <main class="app-main">
            <!-- Canvas Area -->
            <div class="panel canvas-panel">
                <div class="panel-header">
                    <h2 class="panel-title">Diagram Canvas</h2>
                </div>
                <div id="canvas-container" class="panel-body grid-bg">
                    <canvas id="canvas"></canvas>
                    <textarea id="text-editor" class="text-editor"></textarea>
                    <!-- Color HUD: appears near selected block for quick swatches -->
                    <div id="color-hud" class="color-hud hidden" aria-hidden="true"></div>
                </div>
            </div>

            <!-- Mermaid Block Diagram Output -->
            <div class="panel md-panel">
                 <div class="panel-header"><h2 class="panel-title">Mermaid Block Diagram</h2></div>
                <div class="panel-body">
                    <textarea id="markdown-output" readonly title="Generated Mermaid block diagram code"></textarea>
                </div>
            </div>
        </main>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="context-menu">
        <button id="split-h">Split Horizontally</button>
        <button id="split-v">Split Vertically</button>
        <button id="merge">Merge Blocks</button>
    <button id="delete" class="text-red-500">Delete Block</button>
    <button id="delete-connection" class="text-red-500 hidden-item">Delete Connection</button>
    <button id="edit-connection-label" class="hidden-item">Edit Connection Label</button>
    <button id="arrow-line" class="hidden-item">Set Line (---)</button>
    <button id="arrow-forward" class="hidden-item">Set Arrow (-->)</button>
    <button id="arrow-backward" class="hidden-item">Set Arrow (<--)</button>
    </div>

    <!-- Color Palette Modal removed - HUD is used for color changes -->

    <!-- AI features removed -->
    
    <!-- Load Block Diagram Modal -->
    <div id="load-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-header-row">
                <h2 class="modal-title">Load Block Diagram</h2>
                <button id="close-load-modal" class="modal-close">&times;</button>
            </div>
            <div>
                <label for="load-input" class="input-label">Paste your Mermaid block diagram here:</label>
            <!-- Connection tooltip (shows connection label on hover) -->
            <div id="conn-tooltip" class="conn-tooltip hidden"></div>

                <textarea id="load-input" class="w-full h-48 p-2 border border-gray-300 rounded-lg mt-1 font-mono text-sm" placeholder="block&#10;columns 3&#10;  A&#10;  B&#10;  C"></textarea>
            </div>
            <div class="load-footer">
                <button id="load-confirm-btn" class="btn primary">Load Diagram</button>
            </div>
            <p id="load-error" class="error-text hidden"></p>
        </div>
    </div>


    <script>
        // --- DOM ELEMENT REFERENCES ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');
        const markdownOutput = document.getElementById('markdown-output');
        const copyMarkdownBtn = document.getElementById('copy-markdown');
        const clearCanvasBtn = document.getElementById('clear-canvas');
    const fitDiagramBtn = document.getElementById('fit-diagram');
        const arrowModeBtn = document.getElementById('arrow-mode');
        const diagramTitleInput = document.getElementById('diagram-title');
        const textEditor = document.getElementById('text-editor');

        const contextMenu = document.getElementById('context-menu');
        const splitHBtn = document.getElementById('split-h');
        const splitVBtn = document.getElementById('split-v');
        const mergeBtn = document.getElementById('merge');
        const deleteBtn = document.getElementById('delete');

    // AI elements removed

        const loadModal = document.getElementById('load-modal');
        const loadMarkdownBtn = document.getElementById('load-markdown');
        const closeLoadModalBtn = document.getElementById('close-load-modal');
        const loadInput = document.getElementById('load-input');
        const loadConfirmBtn = document.getElementById('load-confirm-btn');
        const loadError = document.getElementById('load-error');

        // --- STATE VARIABLES ---
        const gridSize = 20;
        let blocks = [];
        let connections = []; // Array to store arrow connections {from: blockId, to: blockId, label?: string}
    // Disable autosave during initialization to avoid overwriting existing storage with empty state
    let autosaveEnabled = false;
        let selectedBlocks = new Set();
        let currentBlock = null, editingBlock = null, activeContextMenuBlock = null;
        let drawing = false, dragging = false, resizing = false;
    let arrowMode = false, arrowStart = null; // Arrow creation mode
    let selectedConnections = new Set(); // Set of connection _id strings
    let connectionCounter = 1; // internal connection id counter
    let activeContextMenuConnection = null; // connection object for context menu actions
    let showGhostSpaces = true; // toggle for visualizing space tokens
        let startX, startY, dragOffsetX, dragOffsetY, resizeHandle;
        let dragStartStates = new Map();

        // AI features removed

    // --- Color Presets ---
    // Pleasant pastel palette (12 colors), rearranged to alternate hues (blue, green, orange/pink, ...)
    // Stored without the leading '#'.
    const presetColors = ['93C5FD','7DD3A6','FDE68A',  // light blue, light green, light orange
                           '60A5FA','86EFAC','FCA5A5',  // mid blue, mid green, pink
                           '7DD3FC','BBF7D0','FCD34D',  // cyan, mint, orange
                           'C7B8FF','DBEAFE','FDA4FF']; // lavender, pale indigo, magenta

    // --- Friendly Name Generation ---
    // Generate human-readable block IDs instead of GUIDs
    let blockCounter = 1;
    const friendlyNames = [
        'Task', 'Process', 'Step', 'Action', 'Goal', 'Feature', 'Component', 'Service', 'Module', 'System',
        'Input', 'Output', 'Data', 'Flow', 'Logic', 'Control', 'Interface', 'Handler', 'Manager', 'Provider',
        'Builder', 'Factory', 'Helper', 'Utility', 'Container', 'Wrapper', 'Router', 'Filter', 'Parser', 'Validator',
        'Model', 'View', 'Controller', 'Config', 'Settings', 'Options', 'Params', 'Context', 'State', 'Store',
        'Queue', 'Stack', 'Cache', 'Buffer', 'Pool', 'Registry', 'Catalog', 'Index', 'Database', 'Repository'
    ];
    
    function generateFriendlyId() {
        // Try friendly names first, then fall back to numbered blocks
        if (blockCounter <= friendlyNames.length) {
            const name = friendlyNames[blockCounter - 1];
            blockCounter++;
            
            // Ensure uniqueness - if name already exists, add a number
            const baseName = name;
            let suffix = '';
            let counter = 1;
            while (blocks.some(b => b.id === (baseName + suffix))) {
                suffix = counter.toString();
                counter++;
            }
            return baseName + suffix;
        } else {
            // Fall back to Block1, Block2, etc.
            let id = `Block${blockCounter}`;
            while (blocks.some(b => b.id === id)) {
                blockCounter++;
                id = `Block${blockCounter}`;
            }
            blockCounter++;
            return id;
        }
    }

    // --- Color UI & Logic ---
    // Modal-based color picker removed; HUD provides quick color changes.
    const clearStylesBtn = document.getElementById('clear-styles');

    // Clear all colors from every block and persist the change
    if (clearStylesBtn) {
        clearStylesBtn.addEventListener('click', () => {
            if (!blocks || blocks.length === 0) return;
            for (const b of blocks) { if (b && b.color) delete b.color; }
            draw(); updateMarkdown();
            // Also persist immediately
            saveCanvasState();
        });
    }

    // Assign colors to a block and its descendants in BFS order using successive palette colors
    function assignColorsToTree(rootBlock, startIdx) {
        const queue = [{ node: rootBlock, depth: 0 }];
        const visited = new Set();
        while (queue.length > 0) {
            const { node, depth } = queue.shift();
            if (!node || visited.has(node.id)) continue;
            visited.add(node.id);
            const color = presetColors[(startIdx + depth) % presetColors.length];
            node.color = '#' + color;
            // enqueue children
            const children = blocks.filter(b => b.parentId === node.id);
            children.forEach(c => queue.push({ node: c, depth: depth + 1 }));
        }
    }

    // Remove color property from a block and all its descendants
    function clearColorsFromTree(rootBlock) {
        if (!rootBlock) return;
        const descendants = getDescendants(rootBlock, blocks, true);
        descendants.forEach(b => { if (b && b.color) delete b.color; });
    }


        // --- HELPER & HIERARCHY FUNCTIONS ---
        const getBlockById = id => blocks.find(b => b.id === id);
        const getParent = block => block?.parentId ? getBlockById(block.parentId) : null;
        
        function getDepth(block) {
            let depth = 0;
            let p = getParent(block);
            while (p) { depth++; p = getParent(p); }
            return depth;
        }

        const getTopBlockAtPos = (pos) => {
            const clickedBlocks = blocks.filter(b => pos.x >= b.x && pos.x <= b.x + b.width && pos.y >= b.y && pos.y <= b.y + b.height);
            return clickedBlocks.length > 0 ? clickedBlocks.sort((a, b) => getDepth(a) - getDepth(b)).pop() : null;
        };
        
        function getDescendants(rootBlock, allBlocks, includeSelf = false) {
            const descendants = includeSelf ? [rootBlock] : [];
            const queue = allBlocks.filter(b => b.parentId === rootBlock.id);
            const visited = new Set(queue.map(b => b.id));
            visited.add(rootBlock.id);
            
            while(queue.length > 0) {
                const current = queue.shift();
                descendants.push(current);
                const children = allBlocks.filter(b => b.parentId === current.id);
                for(const child of children) {
                    if(!visited.has(child.id)) {
                        visited.add(child.id);
                        queue.push(child);
                    }
                }
            }
            return descendants;
        }

        const isAncestor = (ancestor, descendant) => {
            let current = getParent(descendant);
            while (current) {
                if (current.id === ancestor.id) return true;
                current = getParent(current);
            }
            return false;
        };

        // --- DRAWING FUNCTIONS ---
        const resizeCanvas = () => {
            // Start with the visible container size
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            // Ensure canvas fits any blocks that extend beyond the visible area
            ensureCanvasFitsBlocks();
            draw();
        };

        // Expand canvas size to include all blocks' extents (do not shrink below container size)
        function ensureCanvasFitsBlocks() {
            try {
                if (!Array.isArray(blocks) || blocks.length === 0) return;
                const margin = 50;
                let maxRight = 0, maxBottom = 0;
                for (const b of blocks) {
                    const right = (typeof b.x === 'number' ? b.x : 0) + (typeof b.width === 'number' ? b.width : 0);
                    const bottom = (typeof b.y === 'number' ? b.y : 0) + (typeof b.height === 'number' ? b.height : 0);
                    if (right > maxRight) maxRight = right;
                    if (bottom > maxBottom) maxBottom = bottom;
                }
                const desiredWidth = Math.max(canvasContainer.clientWidth, Math.ceil(maxRight + margin));
                const desiredHeight = Math.max(canvasContainer.clientHeight, Math.ceil(maxBottom + margin));
                if (canvas.width < desiredWidth) canvas.width = desiredWidth;
                if (canvas.height < desiredHeight) canvas.height = desiredHeight;
            } catch (e) {
                // ignore errors during sizing
            }
        }
        
        function drawBlocks() {
            const sortedBlocks = [...blocks].sort((a, b) => getDepth(a) - getDepth(b));
            sortedBlocks.forEach(block => {
                const isParent = blocks.some(b => b.parentId === block.id);
                // If block has color, use it; otherwise fallback to existing scheme
                if (block.color) {
                    // fill with color, subtle alpha
                    ctx.fillStyle = hexToRgba(block.color, 0.15);
                    ctx.fillRect(block.x, block.y, block.width, block.height);
                    ctx.strokeStyle = block.color;
                } else {
                    ctx.fillStyle = selectedBlocks.has(block) ? 'rgba(59, 130, 246, 0.3)' : isParent ? 'rgba(16, 185, 129, 0.1)' : 'rgba(59, 130, 246, 0.1)';
                    ctx.fillRect(block.x, block.y, block.width, block.height);
                    ctx.strokeStyle = isParent ? '#059669' : '#3B82F6';
                }
                ctx.lineWidth = 2;
                ctx.strokeRect(block.x, block.y, block.width, block.height);
                // Always use a dark text color because the palette uses light pastels
                ctx.fillStyle = '#111827';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = '14px Inter';
                const lines = (block.text || '').split('\n');
                const startYPos = block.y + 8;
                lines.forEach((line, i) => ctx.fillText(line, block.x + block.width / 2, startYPos + i * 16));
            });
            selectedBlocks.forEach(drawResizeHandles);
            
            // Draw arrows/connections
            drawConnections();
        }

        function drawConnections() {
            const blockMap = new Map(blocks.map(b => [b.id, b]));
            
            connections.forEach(conn => {
                const fromBlock = blockMap.get(conn.from);
                const toBlock = blockMap.get(conn.to);
                
                if (!fromBlock || !toBlock) return; // Skip if blocks don't exist
                
                const isSelected = conn._id && selectedConnections.has(conn._id);
                drawArrow(fromBlock, toBlock, conn.label, isSelected, conn.arrowType || '-->');
            });
        }

        function drawArrow(fromBlock, toBlock, label, isSelected = false, arrowType = '-->') {
            // Calculate connection points (center of each block edge)
            const fromCenter = {
                x: fromBlock.x + fromBlock.width / 2,
                y: fromBlock.y + fromBlock.height / 2
            };
            const toCenter = {
                x: toBlock.x + toBlock.width / 2,
                y: toBlock.y + toBlock.height / 2
            };
            
            // Find edge intersection points
            const from = getBlockEdgePoint(fromBlock, toCenter);
            const to = getBlockEdgePoint(toBlock, fromCenter);
            
            // Draw arrow line
            ctx.strokeStyle = isSelected ? '#2563eb' : '#374151';
            ctx.lineWidth = isSelected ? 4 : 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
            
            // Draw arrowhead
            drawArrowhead(from, to, isSelected);
            
            // Draw label if present
            if (label) {
                drawArrowLabel(from, to, label);
            }
        }

        function getBlockEdgePoint(block, targetPoint) {
            const centerX = block.x + block.width / 2;
            const centerY = block.y + block.height / 2;
            
            const dx = targetPoint.x - centerX;
            const dy = targetPoint.y - centerY;
            
            // Calculate intersection with block edges
            const halfWidth = block.width / 2;
            const halfHeight = block.height / 2;
            
            if (Math.abs(dx) * halfHeight > Math.abs(dy) * halfWidth) {
                // Intersects left or right edge
                const x = dx > 0 ? block.x + block.width : block.x;
                const y = centerY + (dy * halfWidth) / Math.abs(dx);
                return { x, y };
            } else {
                // Intersects top or bottom edge
                const x = centerX + (dx * halfHeight) / Math.abs(dy);
                const y = dy > 0 ? block.y + block.height : block.y;
                return { x, y };
            }
        }

        function drawArrowhead(from, to, isSelected) {
            const headlen = 12; // Arrow head length
            const angle = Math.atan2(to.y - from.y, to.x - from.x);

            ctx.fillStyle = isSelected ? '#2563eb' : '#374151';
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawArrowLabel(from, to, label) {
            const midX = (from.x + to.x) / 2;
            const midY = (from.y + to.y) / 2;
            
            ctx.fillStyle = '#374151';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw label background
            const metrics = ctx.measureText(label);
            const padding = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(midX - metrics.width/2 - padding, midY - 6 - padding, metrics.width + 2*padding, 12 + 2*padding);
            
            ctx.fillStyle = '#374151';
            ctx.fillText(label, midX, midY);
        }

    function hexToRgba(hex, alpha) {
        const h = hex.replace('#','');
        const r = parseInt(h.substring(0,2),16);
        const g = parseInt(h.substring(2,4),16);
        const b = parseInt(h.substring(4,6),16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function getContrastingTextColor(bg) {
        try {
            const h = (bg || '#ffffff').replace('#','');
            const r = parseInt(h.substring(0,2),16);
            const g = parseInt(h.substring(2,4),16);
            const b = parseInt(h.substring(4,6),16);
            // Perceptual luminance
            const lum = 0.2126 * (r/255) + 0.7152 * (g/255) + 0.0722 * (b/255);
            return lum > 0.6 ? '#111827' : '#ffffff';
        } catch (e) { return '#111827'; }
    }
    
    // --- Color HUD logic ---
    const colorHud = document.getElementById('color-hud');
    let editingConnection = null; // connection object being edited (for label editing)
    function buildHud() {
        if (!colorHud) return;
        colorHud.innerHTML = '';
        // Clear swatch first
        const clearBtn = document.createElement('button');
        clearBtn.className = 'sw clear-swatch';
        clearBtn.title = 'Clear color';
        clearBtn.innerText = '×';
        clearBtn.onclick = (e) => { e.stopPropagation(); if (selectedBlocks.size === 0) return; for (const b of [...selectedBlocks]) clearColorsFromTree(b); draw(); updateMarkdown(); };
        colorHud.appendChild(clearBtn);
        presetColors.forEach(hex => {
            const sw = document.createElement('button');
            sw.className = 'sw color-swatch-hud';
            sw.style.backgroundColor = '#' + hex;
            sw.dataset.hex = hex;
            sw.title = '#' + hex;
            sw.onclick = (e) => {
                e.stopPropagation();
                if (selectedBlocks.size === 0) return;
                const baseIdx = presetColors.findIndex(h => h.toLowerCase() === hex.toLowerCase());
                for (const b of [...selectedBlocks]) assignColorsToTree(b, baseIdx >= 0 ? baseIdx : 0);
                draw(); updateMarkdown();
            };
            colorHud.appendChild(sw);
        });
    }

    function updateColorHud() {
        if (!colorHud) return;
        if (selectedBlocks.size === 0) { colorHud.classList.add('hidden'); return; }
        if (!colorHud.hasChildNodes()) buildHud();
        const sel = [...selectedBlocks].sort((a,b)=>getDepth(a)-getDepth(b))[0];
        if (!sel) { colorHud.classList.add('hidden'); return; }
        
        // Highlight current block's color in the HUD
        const swatches = colorHud.querySelectorAll('.sw');
        swatches.forEach(sw => sw.classList.remove('current'));
        
        if (sel.color) {
            // Find matching color swatch
            const targetHex = sel.color.replace('#', '').toLowerCase();
            const matchingSwatch = Array.from(swatches).find(sw => {
                const swatchHex = sw.dataset.hex;
                return swatchHex && swatchHex.toLowerCase() === targetHex;
            });
            if (matchingSwatch) {
                matchingSwatch.classList.add('current');
            }
        }
        
        // Position the HUD relative to the canvas coordinates
        // Keep it inside the canvas container
        const containerRect = canvasContainer.getBoundingClientRect();
        const x = Math.min(Math.max(8, sel.x + sel.width + 12), containerRect.width - 120);
        const y = Math.min(Math.max(8, sel.y), containerRect.height - 40);
        colorHud.style.left = x + 'px';
        colorHud.style.top = y + 'px';
        colorHud.classList.remove('hidden');
    }

    // Hide HUD when clicking outside
    document.addEventListener('click', (e)=>{ if (colorHud && !colorHud.contains(e.target)) { colorHud.classList.add('hidden'); } });

    function drawResizeHandles(block) {
            const size = 8, h = size / 2;
            const {x, y, width, height} = block, midX = x + width/2, midY = y + height/2;
            const handles = [ {x, y}, {x: midX, y}, {x: x+width, y}, {x, y: midY}, {x: x+width, y: midY}, {x, y: y+height}, {x: midX, y: y+height}, {x: x+width, y: y+height}];
            ctx.fillStyle = '#3B82F6';
            handles.forEach(p => ctx.fillRect(p.x - h, p.y - h, size, size));
        }

    function draw() { 
        // Ensure canvas covers all blocks before drawing so nothing is clipped
        ensureCanvasFitsBlocks();
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        // Draw ghosted space indicators (visualize where `space` / `space:N` tokens will be emitted)
        drawGhostSpaces();
        drawBlocks(); 
        saveCanvasState(); 
        updateColorHud();
    }

    // Draw subtle 'ghost' rectangles on the canvas to show where the generator
    // will emit `space` tokens between top-level blocks. This mirrors the logic
    // in generateMermaidBlockDiagram() but only for visualization (non-persistent).
    function drawGhostSpaces() {
        if (!showGhostSpaces) return;
        if (!Array.isArray(blocks) || blocks.length === 0) return;
        // Top-level blocks only (spaces are applied between top-level columns)
        const topLevel = blocks.filter(b => !b.parentId);
        if (topLevel.length === 0) return;

    // Compute an inferred grid unit similar to the generator (use median block width to be robust to outliers)
    const pixelWidths = blocks.map(b => b.width || 0).filter(w => w > 0);
    const unit = pixelWidths.length > 0 ? (function(){ const a = pixelWidths.slice().sort((x,y)=>x-y); const m = Math.floor(a.length/2); return (a.length % 2 === 1) ? a[m] : Math.round((a[m-1] + a[m]) / 2); })() : 100;
        const gridUnit = unit > 0 ? unit : 100;

        // Group top-level blocks into rows (same tolerance used by the generator)
        const rowTolerance = 40; // px
        const rows = [];
        for (const b of topLevel) {
            let placed = false;
            for (const r of rows) {
                if (Math.abs(r.y - b.y) <= rowTolerance) { r.blocks.push(b); placed = true; break; }
            }
            if (!placed) rows.push({ y: b.y, blocks: [b] });
        }

        // Overall left-most x used for gap calculations (pixel coordinate)
        const globalMinX = topLevel.length > 0 ? Math.min(...topLevel.map(b => b.x)) : 0;
        const columnPixelWidth = unit > 0 ? unit : 100;

        // Determine columns locally (mirror generator's logic) so the ghost visuals
        // don't rely on a non-existent global `columns` variable which would throw.
        const spanForLocal = (block) => {
            if (block.blockWidth && Number.isFinite(block.blockWidth)) return Math.max(1, block.blockWidth);
            if (block.width && unit > 0) return Math.max(1, Math.round(block.width / unit));
            return 1;
        };

        let columnsLocal = null;
        if (topLevel.length > 0 && typeof topLevel[0]._diagramColumns === 'number') {
            columnsLocal = Math.max(...topLevel.map(b => b._diagramColumns || 0));
        }
        if (!columnsLocal || columnsLocal <= 0) {
            const rowToleranceForColumns = rowTolerance;
            const rowsForColumns = [];
            for (const b of topLevel) {
                let placed = false;
                for (const r of rowsForColumns) {
                    if (Math.abs(r.y - b.y) <= rowToleranceForColumns) { r.blocks.push(b); placed = true; break; }
                }
                if (!placed) rowsForColumns.push({ y: b.y, blocks: [b] });
            }
            let maxRowSpan = 1;
            for (const r of rowsForColumns) {
                let rowSum = 0;
                for (const b of r.blocks) rowSum += spanForLocal(b);
                maxRowSpan = Math.max(maxRowSpan, rowSum);
            }
            columnsLocal = Math.max(1, Math.round(maxRowSpan));
        }

        // Visual style for ghost boxes
        ctx.save();
        ctx.fillStyle = 'rgba(100,100,100,0.06)';
        ctx.strokeStyle = 'rgba(100,100,100,0.14)';
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 6]);

        for (const r of rows) {
            const blocksInRow = r.blocks.slice().sort((a, b) => a.x - b.x);
            const rowHasParents = blocksInRow.some(b => blocks.some(x => x.parentId === b.id));
            if (rowHasParents) continue;

            // Height for the ghost area: use tallest block in the row or a sensible default
            const rowHeight = Math.max(...blocksInRow.map(b => b.height || (gridSize * 3)), gridSize * 3);
            const rowY = r.y;

            let currentColIndex = 0;
            for (const b of blocksInRow) {
                    // Map block x -> column index using floor-based mapping with a small bias
                    // This makes small pixel offsets less likely to flip the column and stabilizes space detection.
                    // Map block x -> column index using a robust rounding strategy to avoid
                    // off-by-one errors when blocks are near column boundaries.
                    // Map block x -> column index using rounding and clamp to last column so
                    // blocks slightly beyond the right edge are still emitted in the last column.
                    let approxCol = Math.max(0, Math.round((b.x - globalMinX) / columnPixelWidth));
                    if (typeof columns === 'number' && columns > 0) approxCol = Math.min(columns - 1, approxCol);
                let gapCols = Math.max(0, approxCol - currentColIndex);
                if (currentColIndex + gapCols > columnsLocal) gapCols = Math.max(0, columnsLocal - currentColIndex);
                if (gapCols > 0) {
                    const ghostWidth = gapCols * columnPixelWidth;
                    const ghostX = globalMinX + currentColIndex * columnPixelWidth;
                    ctx.fillRect(ghostX, rowY, ghostWidth, rowHeight);
                    ctx.strokeRect(ghostX + 0.5, rowY + 0.5, ghostWidth - 1, rowHeight - 1);
                    currentColIndex += gapCols;
                }

                // Advance currentColIndex by the block's span (rounded/clamped)
                const blockSpan = Math.min(Math.max(1, Math.round((b.width || columnPixelWidth) / columnPixelWidth)), Math.max(1, columnsLocal - currentColIndex));
                currentColIndex += blockSpan;
                if (currentColIndex >= columnsLocal) break;
            }
        }

        ctx.restore();
    }
        
        // --- EVENT HANDLERS & LOGIC ---
        const snapToGrid = value => Math.round(value / gridSize) * gridSize;
        const getMousePos = e => { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; };
        
        function isOverResizeHandle(pos, block) {
            if (!selectedBlocks.has(block)) return null;
            const h = 4, {x, y, width, height} = block, midX = x+width/2, midY = y+height/2;
            const inRange = (val, min, max) => val >= min-h && val <= max+h;
            if(inRange(pos.x, x, x) && inRange(pos.y, y, y)) return 'nw';
            if(inRange(pos.x, x+width, x+width) && inRange(pos.y, y, y)) return 'ne';
            if(inRange(pos.x, x, x) && inRange(pos.y, y+height, y+height)) return 'sw';
            if(inRange(pos.x, x+width, x+width) && inRange(pos.y, y+height, y+height)) return 'se';
            if(inRange(pos.x, midX, midX) && inRange(pos.y, y, y)) return 'n';
            if(inRange(pos.x, midX, midX) && inRange(pos.y, y+height, y+height)) return 's';
            if(inRange(pos.x, x, x) && inRange(pos.y, midY, midY)) return 'w';
            if(inRange(pos.x, x+width, x+width) && inRange(pos.y, midY, midY)) return 'e';
            return null;
        }

        function hasOverlap(targetBlock, ignoreSet = new Set()) {
            for (const block of blocks) {
                if (block === targetBlock || ignoreSet.has(block) || isAncestor(targetBlock, block) || isAncestor(block, targetBlock)) continue;
                if (targetBlock.x < block.x + block.width && targetBlock.x + targetBlock.width > block.x && targetBlock.y < block.y + block.height && targetBlock.y + targetBlock.height > block.y) return true;
            }
            return false;
        }

        canvas.addEventListener('mousedown', (e) => {
            hideTextEditor();
            const pos = getMousePos(e);
            dragStartStates.clear();
            let topBlock = getTopBlockAtPos(pos);
            // Check for connection hit (right-click or selection) before block interactions
            const hitConnection = hitTestConnection(pos);
            if (hitConnection) {
                // If right-click, show context menu for connection
                if (e.button === 2) { e.preventDefault(); activeContextMenuConnection = hitConnection; activeContextMenuBlock = null; showContextMenu(e.clientX, e.clientY); return; }
                // Otherwise, select/deselect the connection
                selectedConnections.clear(); selectedBlocks.clear(); selectedConnections.add(hitConnection._id);
                draw(); return;
            } else {
                activeContextMenuConnection = null;
            }
            
            // Handle arrow mode
            if (arrowMode && topBlock) {
                if (!arrowStart) {
                    // First click - select start block
                    arrowStart = topBlock;
                    selectedBlocks.clear();
                    selectedBlocks.add(topBlock);
                } else if (arrowStart && topBlock !== arrowStart) {
                    // Second click - create connection
                    const newConnection = { _id: `conn${connectionCounter++}`, from: arrowStart.id, to: topBlock.id, label: '', arrowType: '-->' };
                    connections.push(newConnection);
                    arrowStart = null;
                    selectedBlocks.clear();
                    draw();
                    updateMarkdown();
                    return;
                } else {
                    // Clicked same block - cancel
                    arrowStart = null;
                    selectedBlocks.clear();
                }
                draw();
                return;
            }
            
            if (topBlock) {
                resizeHandle = isOverResizeHandle(pos, topBlock);
                if (e.button === 2) { e.preventDefault(); activeContextMenuBlock = topBlock; showContextMenu(e.clientX, e.clientY); return; }
                if (resizeHandle) {
                    resizing = true; currentBlock = topBlock;
                    dragStartStates.set(topBlock, { ...topBlock });
                } else {
                    dragging = true; currentBlock = topBlock;
                    if (!e.ctrlKey && !e.shiftKey && !selectedBlocks.has(topBlock)) { selectedBlocks.clear(); selectedBlocks.add(topBlock); }
                    else if (e.ctrlKey || e.shiftKey) { selectedBlocks.has(topBlock) ? selectedBlocks.delete(topBlock) : selectedBlocks.add(topBlock); }
                    dragOffsetX = pos.x - topBlock.x; dragOffsetY = pos.y - topBlock.y;
                    selectedBlocks.forEach(b => dragStartStates.set(b, { ...b }));
                }
            } else {
                if (!e.ctrlKey && !e.shiftKey) selectedBlocks.clear();
                if (e.button !== 2 && !arrowMode) {
                    drawing = true; startX = snapToGrid(pos.x); startY = snapToGrid(pos.y);
                    currentBlock = { id: generateFriendlyId(), parentId: null, x: startX, y: startY, width: 0, height: 0, text: 'New Block' };
                    blocks.push(currentBlock);
                }
            }
            hideContextMenu();
            // Ensure connection tooltip is hidden when context menu is opened
            const tooltip = document.getElementById('conn-tooltip'); if (tooltip) tooltip.classList.add('hidden');
            draw();
        });

        // Hit-test for connections: returns connection object if click is near a connection line
        function hitTestConnection(pos) {
            // tolerance in pixels from the line
            const tol = 6;
            const blockMap = new Map(blocks.map(b => [b.id, b]));
            for (let i = connections.length - 1; i >= 0; i--) {
                const conn = connections[i];
                const from = blockMap.get(conn.from);
                const to = blockMap.get(conn.to);
                if (!from || !to) continue;
                const p1 = getBlockEdgePoint(from, { x: to.x + to.width / 2, y: to.y + to.height / 2 });
                const p2 = getBlockEdgePoint(to, { x: from.x + from.width / 2, y: from.y + from.height / 2 });
                if (pointNearSegment(pos, p1, p2, tol)) return conn;
            }
            return null;
        }

        function pointNearSegment(p, a, b, tol) {
            // Return true if point p is within tol pixels of segment ab
            const vx = b.x - a.x, vy = b.y - a.y;
            const wx = p.x - a.x, wy = p.y - a.y;
            const c1 = vx * wx + vy * wy;
            if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y) <= tol;
            const c2 = vx * vx + vy * vy;
            if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y) <= tol;
            const t = c1 / c2;
            const projX = a.x + t * vx, projY = a.y + t * vy;
            return Math.hypot(p.x - projX, p.y - projY) <= tol;
        }

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            if (!dragging && !drawing) {
                const topBlock = getTopBlockAtPos(pos);
                let cursor = 'default';
                if(topBlock) {
                    const handle = isOverResizeHandle(pos, topBlock);
                    if (handle) {
                        if (['n', 's'].includes(handle)) cursor = 'ns-resize';
                        else if (['e', 'w'].includes(handle)) cursor = 'ew-resize';
                        else if (['nw', 'se'].includes(handle)) cursor = 'nwse-resize';
                        else cursor = 'nesw-resize';
                    } else cursor = 'move';
                }
                canvas.style.cursor = cursor;
            }

            // Tooltip handling: show connection label on hover
            const tooltip = document.getElementById('conn-tooltip');
            const hoverConn = hitTestConnection(pos);
            // Suppress tooltip if the context menu is open for a connection, if we're actively editing a connection,
            // or if the shared text editor (block/conn editor) currently has focus
            const contextOpenForConnection = contextMenu.classList.contains('show') && !!activeContextMenuConnection;
            const editorHasFocus = document.activeElement === textEditor;
            const suppressTooltip = contextOpenForConnection || !!editingConnection || editorHasFocus;
            if (hoverConn && !suppressTooltip) {
                if (tooltip) {
                    tooltip.innerText = hoverConn.label || '(no label)';
                    tooltip.classList.remove('hidden');
                    // Position tooltip near mouse but keep inside container
                    const containerRect = canvasContainer.getBoundingClientRect();
                    const left = Math.min(Math.max(8, e.clientX - containerRect.left + 12), containerRect.width - 120);
                    const top = Math.min(Math.max(8, e.clientY - containerRect.top + 12), containerRect.height - 32);
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                }
            } else {
                if (tooltip) tooltip.classList.add('hidden');
            }

            if (drawing) {
                currentBlock.width = Math.max(gridSize, snapToGrid(pos.x) - startX);
                currentBlock.height = Math.max(gridSize, snapToGrid(pos.y) - startY);
            } else if (dragging) {
                const dx = snapToGrid(pos.x - dragOffsetX) - currentBlock.x;
                const dy = snapToGrid(pos.y - dragOffsetY) - currentBlock.y;
                const allToMove = new Set();
                selectedBlocks.forEach(b => getDescendants(b, blocks, true).forEach(d => allToMove.add(d)));
                allToMove.forEach(b => { b.x += dx; b.y += dy; });
            } else if (resizing) {
                const o = dragStartStates.get(currentBlock), s = {x: snapToGrid(pos.x), y: snapToGrid(pos.y)};
                let {x, y, width, height} = currentBlock;
                if (resizeHandle.includes('w')) { width = o.x + o.width - s.x; if(width >= gridSize) x = s.x; }
                if (resizeHandle.includes('e')) width = s.x - o.x;
                if (resizeHandle.includes('n')) { height = o.y + o.height - s.y; if(height >= gridSize) y = s.y; }
                if (resizeHandle.includes('s')) height = s.y - o.y;
                width = Math.max(gridSize, width); height = Math.max(gridSize, height);
                const children = blocks.filter(b => b.parentId === currentBlock.id);
                if(children.length > 0) {
                    const bounds = children.reduce((a,c) => ({minX:Math.min(a.minX,c.x),minY:Math.min(a.minY,c.y),maxX:Math.max(a.maxX,c.x+c.width),maxY:Math.max(a.maxY,c.y+c.height)}),{minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity});
                    const finalX = resizeHandle.includes('w') ? x : currentBlock.x;
                    const finalY = resizeHandle.includes('n') ? y : currentBlock.y;
                    if (width >= bounds.maxX - finalX) { currentBlock.x = x; currentBlock.width = width; }
                    if (height >= bounds.maxY - finalY) { currentBlock.y = y; currentBlock.height = height; }
                } else { Object.assign(currentBlock, {x, y, width, height}); }
            }
            draw();
        });

        canvas.addEventListener('mouseup', () => {
             if (drawing && (currentBlock.width < gridSize || currentBlock.height < gridSize || hasOverlap(currentBlock))) { blocks.pop(); }
             else if (dragging && currentBlock) {
                let newParent = null;
                const {x, y, width, height} = currentBlock, cX = x + width/2, cY = y + height/2;
                for(const p of blocks.filter(b => b.id !== currentBlock.id && !isAncestor(currentBlock,b))) {
                    if (cX > p.x && cX < p.x + p.width && cY > p.y && cY < p.y + p.height) {
                         if (!newParent || (p.width * p.height < newParent.width * newParent.height)) newParent = p;
                    }
                }
                currentBlock.parentId = (newParent && x >= newParent.x && x+width <= newParent.x+newParent.width && y >= newParent.y && y+height <= newParent.y+newParent.height) ? newParent.id : null;
             } else if ((dragging || resizing) && [...dragStartStates.keys()].some(b => hasOverlap(b, new Set(dragStartStates.keys())))) {
                dragStartStates.forEach((state, block) => Object.assign(block, state));
             }
            drawing = dragging = resizing = false; currentBlock = null; dragStartStates.clear();
            updateMarkdown(); draw();
        });
        
        canvas.addEventListener('dblclick', e => {
            const pos = getMousePos(e);
            // If double-clicked near a connection, open the connection label editor
            const hitConn = hitTestConnection(pos);
            if (hitConn) {
                showConnectionLabelEditor(hitConn);
                return;
            }
            const b = getTopBlockAtPos(pos);
            if (b) showTextEditor(b);
        });

        // Show a lightweight label editor for a connection (reuses the existing textEditor element)
        function showConnectionLabelEditor(conn) {
            editingConnection = conn;
            editingBlock = null; // ensure block editor is not active
            // Hide any visible connection tooltip when entering edit mode
            const tooltip = document.getElementById('conn-tooltip'); if (tooltip) tooltip.classList.add('hidden');
            // position the editor at the midpoint of the connection
            const fromBlock = getBlockById(conn.from);
            const toBlock = getBlockById(conn.to);
            if (!fromBlock || !toBlock) return;
            const fromPt = getBlockEdgePoint(fromBlock, { x: toBlock.x + toBlock.width / 2, y: toBlock.y + toBlock.height / 2 });
            const toPt = getBlockEdgePoint(toBlock, { x: fromBlock.x + fromBlock.width / 2, y: fromBlock.y + fromBlock.height / 2 });
            const midX = Math.round((fromPt.x + toPt.x) / 2);
            const midY = Math.round((fromPt.y + toPt.y) / 2);

            // Show and position the shared textEditor
            textEditor.style.display = 'block';
            textEditor.style.left = (midX - 80) + 'px';
            textEditor.style.top = (midY - 12) + 'px';
            textEditor.style.width = '160px';
            textEditor.style.height = '28px';
            textEditor.value = conn.label || '';
            textEditor.focus();
            textEditor.select();

            // Highlight the connection while editing
            selectedConnections.clear(); selectedBlocks.clear(); if (conn._id) selectedConnections.add(conn._id);
            draw();
        }
        
        function showTextEditor(block) {
            editingBlock = block;
            Object.assign(textEditor.style, { display: 'block', left: `${block.x}px`, top: `${block.y}px`, width: `${block.width}px`, height: `${block.height}px` });
            textEditor.value = block.text.replace(/\\n/g, '\n'); textEditor.focus(); textEditor.select();
            // Ensure the connection tooltip is hidden while the text editor is focused for editing blocks
            const tooltip = document.getElementById('conn-tooltip'); if (tooltip) tooltip.classList.add('hidden');
        }
        function hideTextEditor() {
            if (editingConnection) {
                // Save connection label
                editingConnection.label = textEditor.value || '';
                editingConnection = null;
                textEditor.style.display = 'none';
                selectedConnections.clear();
                draw(); updateMarkdown();
                return;
            }
            if (!editingBlock) return;
            editingBlock.text = textEditor.value.replace(/\n/g, '\\n');
            editingBlock = null; textEditor.style.display = 'none'; draw(); updateMarkdown();
        }
        textEditor.addEventListener('blur', hideTextEditor);
        textEditor.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); hideTextEditor(); }
            if (e.key === 'Escape') { editingBlock = null; editingConnection = null; textEditor.style.display = 'none'; draw(); }
        });
        
        // --- CONTEXT MENU & ACTIONS ---
        function showContextMenu(x, y) {
            Object.assign(contextMenu.style, {left:`${x}px`, top:`${y}px`}); contextMenu.classList.add('show');
            const canMerge = selectedBlocks.size > 1; mergeBtn.disabled=!canMerge; Object.assign(mergeBtn.style, {cursor:canMerge?'pointer':'not-allowed',opacity:canMerge?1:0.5});
            // Show delete-connection button only when a connection was right-clicked
            const deleteConnBtn = document.getElementById('delete-connection');
            const editConnBtn = document.getElementById('edit-connection-label');
            const splitHBtn = document.getElementById('split-h');
            const splitVBtn = document.getElementById('split-v');
            const mergeBtnEl = document.getElementById('merge');
            const deleteBtnEl = document.getElementById('delete');
            // Only show connection actions when the context menu was opened on a connection (not on a block)
            const showConnActions = !!activeContextMenuConnection && !activeContextMenuBlock;
            // When showing connection actions, hide block-specific actions; otherwise show block actions
            if (deleteConnBtn) {
                if (showConnActions) deleteConnBtn.classList.remove('hidden-item'); else deleteConnBtn.classList.add('hidden-item');
            }
            if (editConnBtn) {
                if (showConnActions) editConnBtn.classList.remove('hidden-item'); else editConnBtn.classList.add('hidden-item');
            }

            // Show/hide arrow type buttons for connections
            const arrowLineBtn = document.getElementById('arrow-line');
            const arrowForwardBtn = document.getElementById('arrow-forward');
            const arrowBackwardBtn = document.getElementById('arrow-backward');
            const arrowBtns = [arrowLineBtn, arrowForwardBtn, arrowBackwardBtn];
            for (const btn of arrowBtns) {
                if (!btn) continue;
                if (showConnActions) btn.classList.remove('hidden-item'); else btn.classList.add('hidden-item');
            }

            const blockActions = [splitHBtn, splitVBtn, mergeBtnEl, deleteBtnEl];
            for (const el of blockActions) {
                if (!el) continue;
                if (showConnActions) el.style.display = 'none'; else el.style.display = '';
            }
        }
    function hideContextMenu() { contextMenu.classList.remove('show'); activeContextMenuBlock = null; activeContextMenuConnection = null; }
    window.addEventListener('click', e => { if (!contextMenu.contains(e.target)) hideContextMenu(); });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        const createAndAddBlock = (props) => { blocks.push({ id: generateFriendlyId(), parentId: activeContextMenuBlock.parentId, text: 'New Block', ...props }); hideContextMenu(); draw(); updateMarkdown(); };
        splitHBtn.addEventListener('click', () => { if(!activeContextMenuBlock) return; const h = snapToGrid(activeContextMenuBlock.height/2); createAndAddBlock({ ...activeContextMenuBlock, y: activeContextMenuBlock.y+h, height:activeContextMenuBlock.height-h}); activeContextMenuBlock.height = h; });
        splitVBtn.addEventListener('click', () => { if(!activeContextMenuBlock) return; const w = snapToGrid(activeContextMenuBlock.width/2); createAndAddBlock({ ...activeContextMenuBlock, x: activeContextMenuBlock.x+w, width:activeContextMenuBlock.width-w}); activeContextMenuBlock.width = w; });
        deleteBtn.addEventListener('click', () => { const toDelete = new Set(selectedBlocks.size > 0 ? [...selectedBlocks] : (activeContextMenuBlock ? [activeContextMenuBlock] : [])); if (toDelete.size > 0) deleteBlocks(toDelete); hideContextMenu(); draw(); updateMarkdown(); });
        const deleteConnBtn = document.getElementById('delete-connection');
        if (deleteConnBtn) {
            deleteConnBtn.addEventListener('click', () => {
                if (activeContextMenuConnection) {
                    connections = connections.filter(c => c._id !== activeContextMenuConnection._id);
                    activeContextMenuConnection = null;
                } else if (selectedConnections.size > 0) {
                    connections = connections.filter(c => !selectedConnections.has(c._id));
                    selectedConnections.clear();
                }
                hideContextMenu(); draw(); updateMarkdown();
            });
        }
        const editConnBtn = document.getElementById('edit-connection-label');
        if (editConnBtn) {
            editConnBtn.addEventListener('click', () => {
                const targetConn = activeContextMenuConnection || (connections.find(c => selectedConnections.has(c._id)) || null);
                if (targetConn) {
                    showConnectionLabelEditor(targetConn);
                }
                hideContextMenu();
            });
        }
        
        // Arrow type buttons
        const arrowLineBtn = document.getElementById('arrow-line');
        const arrowForwardBtn = document.getElementById('arrow-forward');
        const arrowBackwardBtn = document.getElementById('arrow-backward');
        
        if (arrowLineBtn) {
            arrowLineBtn.addEventListener('click', () => {
                const targetConn = activeContextMenuConnection || (connections.find(c => selectedConnections.has(c._id)) || null);
                if (targetConn) {
                    targetConn.arrowType = '---';
                    draw(); updateMarkdown();
                }
                hideContextMenu();
            });
        }
        
        if (arrowForwardBtn) {
            arrowForwardBtn.addEventListener('click', () => {
                const targetConn = activeContextMenuConnection || (connections.find(c => selectedConnections.has(c._id)) || null);
                if (targetConn) {
                    targetConn.arrowType = '-->';
                    draw(); updateMarkdown();
                }
                hideContextMenu();
            });
        }
        
        if (arrowBackwardBtn) {
            arrowBackwardBtn.addEventListener('click', () => {
                const targetConn = activeContextMenuConnection || (connections.find(c => selectedConnections.has(c._id)) || null);
                if (targetConn) {
                    // For backwards arrow, swap from/to and use forward arrow type
                    const tempFrom = targetConn.from;
                    targetConn.from = targetConn.to;
                    targetConn.to = tempFrom;
                    targetConn.arrowType = '-->';
                    draw(); updateMarkdown();
                }
                hideContextMenu();
            });
        }
        mergeBtn.addEventListener('click', () => { if(selectedBlocks.size<=1) return; const arr=[...selectedBlocks], b = arr.reduce((a,c)=>({minX:Math.min(a.minX,c.x),minY:Math.min(a.minY,c.y),maxX:Math.max(a.maxX,c.x+c.width),maxY:Math.max(a.maxY,c.y+c.height)}),{minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity}); const txt = arr.map(c=>c.text).filter(t=>t&&t.trim()!=='New Block').join(' / '); blocks=blocks.filter(c=>!selectedBlocks.has(c)); const newBlock={id:generateFriendlyId(),parentId:arr[0].parentId,x:b.minX,y:b.minY,width:b.maxX-b.minX,height:b.maxY-b.minY,text:txt||'Merged'}; blocks.push(newBlock); selectedBlocks.clear(); selectedBlocks.add(newBlock); hideContextMenu(); draw(); updateMarkdown(); });
        
        // --- HEADER BUTTONS & MERMAID GENERATION ---
        copyMarkdownBtn.addEventListener('click', () => { markdownOutput.select(); document.execCommand('copy'); const t=copyMarkdownBtn.innerText; copyMarkdownBtn.innerText='Copied!'; setTimeout(()=>copyMarkdownBtn.innerText=t,2000);});
        clearCanvasBtn.addEventListener('click', () => { blocks=[]; connections=[]; selectedBlocks.clear(); diagramTitleInput.value=''; draw(); updateMarkdown(); });
    fitDiagramBtn.addEventListener('click', () => { scrollCanvasToFitBlocks(); });
        arrowModeBtn.addEventListener('click', () => { 
            arrowMode = !arrowMode; 
            arrowModeBtn.textContent = arrowMode ? '🔗 Exit Arrow Mode' : '🔗 Arrow Mode';
            arrowModeBtn.className = arrowMode ? 'btn primary' : 'btn secondary';
            arrowStart = null;
            canvas.style.cursor = arrowMode ? 'crosshair' : 'default';
        });
        const toggleGhostBtn = document.getElementById('toggle-ghost-spaces');
        if (toggleGhostBtn) {
            toggleGhostBtn.addEventListener('click', () => {
                showGhostSpaces = !showGhostSpaces;
                toggleGhostBtn.textContent = `Ghost spaces: ${showGhostSpaces ? 'On' : 'Off'}`;
                toggleGhostBtn.className = showGhostSpaces ? 'btn primary' : 'btn ghost';
                draw();
            });
        }
        diagramTitleInput.addEventListener('input', updateMarkdown);

    // --- Persistence: save/load canvas state to localStorage ---
        const STORAGE_KEY = 'blockitecht.canvas.v1';

        function saveCanvasState() {
            try {
                if (!autosaveEnabled) return; // skip saving during initialization
                // Don't overwrite an existing saved diagram with an empty canvas/title
                if ((!blocks || blocks.length === 0) && !diagramTitleInput.value.trim()) return;
                // Create a JSON-safe snapshot of blocks and connections
                const blocksSnapshot = blocks.map(b => {
                    const { id, x, y, width, height, text, parentId, blockWidth, originalId, color } = b;
                    return { id, x, y, width, height, text, parentId, blockWidth, originalId, color };
                });
                const connectionsSnapshot = (connections || []).map(c => ({
                    _id: c._id || null,
                    from: c.from,
                    to: c.to,
                    label: c.label || '',
                    arrowType: c.arrowType || '-->'
                }));
                const payload = { title: diagramTitleInput.value || '', blocks: blocksSnapshot, connections: connectionsSnapshot };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
                // Log success for debugging in browser console
                console.log('Saved canvas state to localStorage (blocks:', blocksSnapshot.length, 'connections:', connectionsSnapshot.length, ')');
            } catch (e) { console.warn('Failed to save canvas state', e); }
        }

        function loadCanvasState() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return false;
                const parsed = JSON.parse(raw);
                if (parsed && Array.isArray(parsed.blocks)) {
                    // Ensure loaded blocks are snapped to grid (we already snap on manual load too)
                    const snapFloor = v => Math.floor(v / gridSize) * gridSize;
                    // Reconstruct blocks (plain objects) from snapshot
                    const reconstructed = parsed.blocks.map(b => {
                        return {
                            id: b.id,
                            x: typeof b.x === 'number' ? snapFloor(b.x) : 0,
                            y: typeof b.y === 'number' ? snapFloor(b.y) : 0,
                            width: typeof b.width === 'number' ? Math.max(gridSize, Math.floor(b.width / gridSize) * gridSize) : gridSize,
                            height: typeof b.height === 'number' ? Math.max(gridSize, Math.floor(b.height / gridSize) * gridSize) : gridSize,
                            text: b.text || b.id,
                            parentId: b.parentId || null,
                            blockWidth: b.blockWidth || (b.blockWidth === 0 ? 0 : 1),
                            originalId: b.originalId,
                            color: b.color || null
                        };
                    });

                    blocks = reconstructed;
                    // Restore connections and ensure each has a unique _id
                    const loadedConnections = (parsed.connections || []).map(c => ({ _id: c._id || `conn${connectionCounter++}`, from: c.from, to: c.to, label: c.label || '', arrowType: c.arrowType || '-->' }));
                    connections = loadedConnections;
                    diagramTitleInput.value = parsed.title || '';
                    selectedBlocks.clear();
                    draw();
                    updateMarkdown();
                    // Scroll container to show the loaded diagram
                    scrollCanvasToFitBlocks();
                    console.log('Loaded canvas state from localStorage (blocks:', blocks.length, 'connections:', connections.length, ')');
                    return true;
                }
            } catch (e) { console.warn('Failed to load canvas state', e); }
            return false;
        }

    // Clear stored state when clearing canvas
    clearCanvasBtn.addEventListener('click', () => { localStorage.removeItem(STORAGE_KEY); blocks = []; selectedBlocks.clear(); diagramTitleInput.value = ''; draw(); updateMarkdown(); });

        // Load any persisted state on startup and enable autosave afterwards
        document.addEventListener('DOMContentLoaded', () => {
            // Resize canvas now that DOM is ready
            resizeCanvas();
            const loaded = loadCanvasState();
            if (loaded) console.log('Loaded saved canvas state from localStorage');
            // Enable autosave after initial load so we don't overwrite stored state
            autosaveEnabled = true;
        });

        function updateMarkdown() {
            let title = diagramTitleInput.value.trim();
            let output = '';
            if (title) {
                output += `# ${title}\n\n`;
            }
            const topLevelBlocks = blocks.filter(b => !b.parentId);
            if (topLevelBlocks.length > 0) {
                output += generateMermaidBlockDiagram(topLevelBlocks);
            } else {
                output += 'block\ncolumns 3\n  %% Add blocks to the canvas to generate diagram';
            }
            markdownOutput.value = output;
            // Persist canvas state whenever the markdown/diagram is updated
            saveCanvasState();
        }

        // --- TEST HARNESS ---

        function deleteBlocks(startingBlocks) {
            const allToDelete = new Set();
            startingBlocks.forEach(b => getDescendants(b, blocks, true).forEach(d => allToDelete.add(d.id)));
            blocks = blocks.filter(b => !allToDelete.has(b.id));
            selectedBlocks = new Set([...selectedBlocks].filter(b => !allToDelete.has(b.id)));
        }
        window.addEventListener('keydown', (e) => {
            if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
            // Toggle Arrow Mode with 'A' or 'a'
            if (e.key === 'A' || e.key === 'a') {
                e.preventDefault();
                arrowMode = !arrowMode;
                arrowModeBtn.textContent = arrowMode ? '🔗 Exit Arrow Mode' : '🔗 Arrow Mode';
                arrowModeBtn.className = arrowMode ? 'btn primary' : 'btn secondary';
                arrowStart = null;
                canvas.style.cursor = arrowMode ? 'crosshair' : 'default';
                selectedConnections.clear(); selectedBlocks.clear(); draw();
                return;
            }

            // Delete selected connections first, otherwise delete selected blocks
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedConnections.size > 0) {
                e.preventDefault();
                // Remove connections whose _id is in selectedConnections
                connections = connections.filter(c => !selectedConnections.has(c._id));
                selectedConnections.clear();
                draw(); updateMarkdown();
                return;
            }

            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedConnections.size === 0 && selectedBlocks.size > 0) {
                e.preventDefault(); deleteBlocks(selectedBlocks); draw(); updateMarkdown();
            }
        });
        
        // AI features removed

        // --- LOAD MODAL LOGIC ---
        loadMarkdownBtn.addEventListener('click', () => {
            loadInput.value = '';
            loadError.classList.add('hidden');
            loadModal.classList.remove('hidden');
            setTimeout(() => loadInput.focus(), 0); // Focus textarea after modal is visible
        });
        closeLoadModalBtn.addEventListener('click', () => loadModal.classList.add('hidden'));

        function parseHtmlToBlocks(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const table = doc.querySelector('table');
            if (!table) return [];

            const parsedBlocks = [];
            const tempGrid = [];
            const rows = table.querySelectorAll(':scope > tbody > tr, :scope > tr');

            rows.forEach((row, r) => {
                if (!tempGrid[r]) tempGrid[r] = [];
                let currentC = 0;
                Array.from(row.children).forEach(cell => {
                    while (tempGrid[r][currentC]) { currentC++; }

                    const colspan = parseInt(cell.getAttribute('colspan') || '1');
                    const rowspan = parseInt(cell.getAttribute('rowspan') || '1');
                    const width = colspan * gridSize * 2;
                    const height = rowspan * gridSize * 2;
                    const x = currentC * gridSize * 2;
                    const y = r * gridSize * 2;
                    
                    const newBlock = { id: generateFriendlyId(), parentId: null, x, y, width, height, text: '' };

                    // Handle nested tables first, recursively
                    const nestedTable = cell.querySelector('table');
                    if (nestedTable) {
                        const children = parseHtmlToBlocks(nestedTable.outerHTML);
                        children.forEach(child => {
                            child.parentId = newBlock.id;
                            child.x += newBlock.x;
                            child.y += newBlock.y;
                        });
                        parsedBlocks.push(...children);
                        nestedTable.parentElement.removeChild(nestedTable); // Remove after parsing
                    }

                    // Extract text content from the cell (now without the nested table)
                    let cellText = (cell.innerHTML || "").replace(/<br\s*\/?>/gi, '\\n');
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = cellText;
                    newBlock.text = (tempDiv.textContent || "").trim();

                    parsedBlocks.push(newBlock);

                    for (let i = r; i < r + rowspan; i++) {
                        if (!tempGrid[i]) tempGrid[i] = [];
                        for (let j = currentC; j < currentC + colspan; j++) {
                            tempGrid[i][j] = newBlock;
                        }
                    }
                    currentC += colspan;
                });
            });

            return parsedBlocks; // Return all blocks, unfiltered
        }

        function parseBlockDiagramInput(input) {
            // Parse Mermaid block diagram syntax and create blocks
            
            // Extract title from block comment, title: line, or Markdown heading (lines starting with '#')
            const titleMatch = input.match(/^%%\s*(.*?)\s*%%/m) || input.match(/^title:\s*(.*?)$/m) || input.match(/^#\s*(.*?)$/m);
            const title = titleMatch ? titleMatch[1].trim() : '';
            
            // Extract columns directive
            const columnsMatch = input.match(/^columns\s+(\d+)\s*$/m);
            const columnCount = columnsMatch ? parseInt(columnsMatch[1]) : 3; // default to 3 columns
            
            // Remove comments, title, block, and columns lines for parsing
         const cleanInput = input
          .split('\n')
          .filter(line => !line.trim().match(/^%%/) && !line.trim().match(/^title:/) && !line.trim().match(/^#\s*/) &&
              !line.trim().match(/^block\s*$/) && !line.trim().match(/^columns\s+\d+\s*$/))
          .join('\n');
            
            // Parse block definitions and connections with nesting support
            const lines = cleanInput.split('\n');
            const blockMap = new Map();
            const connections = [];
            const parentStack = []; // Stack to track current parent context
            
            // Grid positioning based on column count
            let currentRow = 0;
            let currentCol = 0;
            // When a 'space' token is parsed we set this flag so the next block
            // placement can skip the usual wrap behavior. This lets explicit
            // 'space' tokens push blocks to the right on the same row, allowing
            // the generator to later infer a larger column count.
            let skipNextWrap = false;
            const blockWidth = 120;
            const blockHeight = 80;
            const padding = 20;
            
            function calculatePosition(row, col) {
                const x = col * (blockWidth + padding) + 50;
                const y = row * (blockHeight + padding) + 50;
                return { x, y };
            }
            
            function createBlock(blockId, label, parentId = null, useGrid = true, widthFactor = 1) {
                // If block already exists, possibly update its blockWidth and return it
                if (blockMap.has(blockId)) {
                    const existing = blockMap.get(blockId);
                    if (widthFactor && (!existing.blockWidth || widthFactor > existing.blockWidth)) {
                        existing.blockWidth = widthFactor;
                    }
                    return existing;
                }

                let x, y, width = 100, height = 60;
                // Determine width factor: prefer explicit param, otherwise default to 1
                let blockWidthFactor = Math.max(1, widthFactor || 1);

                if (useGrid && !parentId) {
                    // Use grid positioning for top-level blocks
                    const pos = calculatePosition(currentRow, currentCol);
                    x = pos.x;
                    y = pos.y;
                    // Apply width factor to block pixel width
                    width = 100 * blockWidthFactor;

                    // Advance grid position by the width factor (span columns)
                    currentCol += blockWidthFactor;
                    if (skipNextWrap) {
                        // Honor the skip for a single placement then clear the flag
                        skipNextWrap = false;
                    } else {
                        while (currentCol >= columnCount) {
                            currentCol -= columnCount;
                            currentRow++;
                        }
                    }
                } else if (parentId) {
                    // Position child blocks inside parent with proper layout
                    const parent = blockMap.get(parentId);
                    if (parent) {
                        // Count existing children to determine position
                        const existingChildren = Array.from(blockMap.values()).filter(b => b.parentId === parentId);
                        const childIndex = existingChildren.length;
                        
                        // Layout children in a grid within the parent
                        const childPadding = 10;
                        const childWidth = 80;
                        const childHeight = 40;
                        const childrenPerRow = Math.max(1, Math.floor((parent.width - 2 * childPadding) / (childWidth + childPadding)));
                        
                        const childRow = Math.floor(childIndex / childrenPerRow);
                        const childCol = childIndex % childrenPerRow;
                        
                        x = parent.x + childPadding + childCol * (childWidth + childPadding);
                        y = parent.y + 30 + childRow * (childHeight + childPadding);
                        width = childWidth;
                        height = childHeight;
                        
                        // Ensure parent is large enough to contain all children
                        const requiredWidth = Math.max(120, 2 * childPadding + childrenPerRow * (childWidth + childPadding));
                        const requiredHeight = Math.max(80, 30 + (childRow + 1) * (childHeight + childPadding) + childPadding);
                        
                        parent.width = Math.max(parent.width, requiredWidth);
                        parent.height = Math.max(parent.height, requiredHeight);
                    } else {
                        // Fallback positioning
                        const pos = calculatePosition(currentRow, currentCol);
                        x = pos.x;
                        y = pos.y;
                    }
                } else {
                    // Fallback positioning
                    const pos = calculatePosition(currentRow, currentCol);
                    x = pos.x;
                    y = pos.y;
                }

                const block = {
                    id: blockId,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    text: label || blockId,
                    parentId: parentId,
                    blockWidth: blockWidthFactor
                };

                blockMap.set(blockId, block);
                return block;
            }
            
            // Preprocess lines to convert new label syntax (A -- \"label\" --> B) to old syntax (A --> |\"label\"| B)
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Skip classDef and class statements - these should not be preprocessed
                if (trimmed.startsWith('classDef ') || trimmed.startsWith('class ')) {
                    continue;
                }
                
                // Convert new label format to old format that existing parser understands
                const newLabelMatch = trimmed.match(/^([A-Za-z0-9_-]+)\s+--\s+"([^"]+)"\s+(-->|---|<--)\s+([A-Za-z0-9_-]+)$/);
                if (newLabelMatch) {
                    const [, fromId, label, arrowType, toId] = newLabelMatch;
                    const converted = `  ${fromId} ${arrowType} |"${label}"| ${toId}`;
                    lines[i] = converted;
                }
            }
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                const indent = line.length - line.trimStart().length;
                // Reset column cursor at the start of each logical line so leading `space` tokens
                // apply to the current row rather than accumulating from previous rows.
                currentCol = 0;

                if (!trimmed) continue;
                
                // Skip classDef and class statements - these will be handled in post-processing
                if (trimmed.startsWith('classDef ') || trimmed.startsWith('class ')) {
                    continue;
                }
                
                // Handle end keyword - pop from parent stack
                if (trimmed === 'end') {
                    parentStack.pop();
                    continue;
                }
                
                // Parse block:ID syntax - starts a new parent block (allow hyphens in IDs)
                // Allow optional label and color annotation after block:ID like `block:ID["Label"] %%color:93C5FD`
                const blockColonMatch = trimmed.match(/^block:([\w-]+)(?:\["([^\"]*)"\])?(?:\s+%%color:(#?[0-9A-Fa-f]{6}))?$/);
                if (blockColonMatch) {
                    const [, blockId, labelMatch, colorMatch] = blockColonMatch;
                    const currentParent = parentStack.length > 0 ? parentStack[parentStack.length - 1] : null;

                    // Create or fetch; if a label is explicitly provided use it, otherwise preserve any existing label
                    const block = createBlock(blockId, labelMatch || blockId, currentParent);
                    block.originalId = blockId;
                    if (labelMatch && labelMatch.trim()) {
                        block.text = labelMatch;
                    }
                    if (colorMatch) {
                        block.color = colorMatch.startsWith('#') ? colorMatch : '#' + colorMatch;
                    }

                    parentStack.push(blockId);
                    continue;
                }
                
                // If this line is a connection (e.g. "A --> B", "A --- B", "A <-- B"), parse it
                // Use a small string-based parser instead of a complex regex literal to avoid
                // editor/HTML linter issues with escape sequences inside the <script>.
                let arrowIndex = -1;
                let arrowType = '';
                let arrowLength = 0;
                
                // Check for different arrow types
                if ((arrowIndex = trimmed.indexOf('-->')) !== -1) {
                    arrowType = '-->';
                    arrowLength = 3;
                } else if ((arrowIndex = trimmed.indexOf('<--')) !== -1) {
                    arrowType = '<--';
                    arrowLength = 3;
                } else if ((arrowIndex = trimmed.indexOf('---')) !== -1) {
                    arrowType = '---';
                    arrowLength = 3;
                }
                
                if (arrowIndex !== -1) {
                    const left = trimmed.slice(0, arrowIndex).trim();
                    let right = trimmed.slice(arrowIndex + arrowLength).trim();
                    let fromId = left;
                    let toId = '';
                    let label = '';

                    // If the right side starts with |" then expect a label of the form |"..."| followed by the target id
                    if (right.startsWith('|"')) {
                        const endLabelIdx = right.indexOf('"|', 2);
                        if (endLabelIdx !== -1) {
                            label = right.slice(2, endLabelIdx);
                            toId = right.slice(endLabelIdx + 2).trim();
                        } else {
                            // malformed; treat whole right as toId fallback
                            toId = right;
                        }
                    } else {
                        // No inline label, right side should be the target id
                        toId = right.split(/\s+/)[0];
                    }

                    // Handle backwards arrow by swapping from/to
                    if (arrowType === '<--') {
                        [fromId, toId] = [toId, fromId];
                        arrowType = '-->';
                    }

                    // Validate simple id shapes before accepting (allow hyphens for UUIDs)
                    if (/^[\w-]+$/.test(fromId) && /^[\w-]+$/.test(toId)) {
                        const currentParent = parentStack.length > 0 ? parentStack[parentStack.length - 1] : null;
                        // Ensure both blocks exist - don't advance grid for connection-implied blocks
                        createBlock(fromId, fromId, currentParent, false);
                        createBlock(toId, toId, currentParent, false);
                        connections.push({ from: fromId, to: toId, label: label || '', arrowType: arrowType });
                        continue;
                    }
                    // fallthrough to token parsing if it wasn't a valid connection line
                }

                // Tokenize the trimmed line into block tokens or space tokens so we support multiple
                // definitions on the same line (e.g. `a["A label"] b:2 c:2 d`). This regex matches
                // either a space token or a block token (id, optional :width, optional ["label"]).
                // Tokenize block tokens; allow IDs containing letters, digits, underscore and hyphen
                const tokenRegex = /(?:space(?::\d+)?)|(?:[\w-]+(?::\d+)?(?:\["[^\"]*"\])?)/g;
                let match;
                const currentParent = parentStack.length > 0 ? parentStack[parentStack.length - 1] : null;
                while ((match = tokenRegex.exec(trimmed)) !== null) {
                    const token = match[0];
                    // If this token has an inline color annotation following it like '... %%color:#RRGGBB',
                    // try to capture that from the remaining substring after this token.
                    let color = null;
                    const after = trimmed.slice(tokenRegex.lastIndex);
                    const colorMatch = after.match(/^(?:\s*%%color:(#?[0-9A-Fa-f]{6}))/);
                    if (colorMatch) {
                        color = colorMatch[1].startsWith('#') ? colorMatch[1] : '#' + colorMatch[1];
                        // advance the regex index past the color annotation so it doesn't get reprocessed
                        tokenRegex.lastIndex += colorMatch[0].length;
                    }
                    if (/^space/.test(token)) {
                        const sm = token.match(/^space(?::(\d+))?$/);
                        const spaceWidth = sm && sm[1] ? parseInt(sm[1]) : 1;
                        // Advance the column cursor and mark that the next block
                        // placement should skip the normal wrapping behavior so the
                        // explicit space can push placement to the right on the
                        // current row rather than immediately wrapping.
                        currentCol += spaceWidth;
                        skipNextWrap = true;
                        continue;
                    }

                    // Block token
                    // Allow hyphens in block id (UUIDs include hyphens)
                    const bm = token.match(/^([\w-]+)(?::(\d+))?(?:\["([^\"]+)"\])?$/);
                    if (bm) {
                        const [, blockId, widthStr, label] = bm;
                        const widthFactor = widthStr ? parseInt(widthStr) : 1;
                        const blk = createBlock(blockId, label, currentParent, true, widthFactor);
                        if (color) blk.color = color;
                    }
                }

                // After processing tokens on this input line, advance to the next row so
                // subsequent logical lines are placed on the next canvas row.
                // (Lines that used 'continue' earlier — e.g. connections, block:ID, end —
                // will have skipped token processing and won't reach this increment.)
                currentRow++;
            }
            
            // Convert Map to Array for the blocks
            const newBlocks = Array.from(blockMap.values());

            // Parse classDef and class statements for color information
            const classDefs = new Map();
            for (let i = 0; i < lines.length; i++) {
                const trimmed = lines[i].trim();
                
                // Parse classDef statements: classDef className fill:#color,stroke:#333,stroke-width:2px;
                const classDefMatch = trimmed.match(/^classDef\s+([\w]+)\s+fill:(#[0-9A-Fa-f]{6})[,;]/);
                if (classDefMatch) {
                    const [, className, fillColor] = classDefMatch;
                    classDefs.set(className, fillColor);
                    continue;
                }
                
                // Parse class statements: class blockId className
                const classMatch = trimmed.match(/^class\s+([\w-]+)\s+([\w]+)$/);
                if (classMatch) {
                    const [, blockId, className] = classMatch;
                    const color = classDefs.get(className);
                    if (color) {
                        const block = newBlocks.find(b => b.id === blockId);
                        if (block) {
                            block.color = color;
                        }
                    }
                    continue;
                }
            }

            // Attach original diagram column count to parsed blocks so a generator
            // can prefer the original `columns N` directive during round-trip.
            newBlocks.forEach(b => { b._diagramColumns = columnCount; });
            
            return { title, blocks: newBlocks, connections };
        }

        // --- Mermaid Generator ---
        function detectAndCreateVerticalSpans(topLevelBlocks) {
            // Only apply vertical span detection when there are at least 3 blocks
            // and there's evidence of a vertical spanning layout
            if (topLevelBlocks.length < 3) {
                return topLevelBlocks;
            }
            
            // Group blocks into columns based on X position (with tolerance)
            const columnTolerance = 50; // px tolerance for column alignment
            const rowTolerance = 20;    // px tolerance for row alignment
            
            // Sort blocks by X position to process columns left to right
            const sortedBlocks = topLevelBlocks.slice().sort((a, b) => a.x - b.x);
            const columns = [];
            
            // Group blocks into columns
            for (const block of sortedBlocks) {
                let placed = false;
                for (const col of columns) {
                    // Check if block overlaps horizontally with this column
                    const colLeft = Math.min(...col.blocks.map(b => b.x));
                    const colRight = Math.max(...col.blocks.map(b => b.x + b.width));
                    const blockLeft = block.x;
                    const blockRight = block.x + block.width;
                    
                    // Check for horizontal overlap with proper logic
                    // Two ranges overlap if: left1 < right2 AND left2 < right1
                    const overlaps = blockLeft < colRight && colLeft < blockRight;
                    
                    if (overlaps) {
                        col.blocks.push(block);
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    columns.push({ blocks: [block] });
                }
            }
            
            // Only proceed if we have exactly 2 columns (classic vertical span scenario)
            if (columns.length !== 2) {
                return topLevelBlocks;
            }
            
            // Process each column to detect vertical spans
            const resultBlocks = [];
            let invisibleParentCounter = 1;
            
            for (const column of columns) {
                if (column.blocks.length <= 1) {
                    // Single block column, check if it spans multiple row heights
                    if (column.blocks.length === 1) {
                        resultBlocks.push(column.blocks[0]);
                    }
                    continue;
                }
                
                // Sort blocks in column by Y position
                column.blocks.sort((a, b) => a.y - b.y);
                
                // Check if this column has blocks that could be grouped opposite a spanning block
                // Look for 2 or more blocks that are vertically stacked
                const avgBlockHeight = column.blocks.reduce((sum, b) => sum + b.height, 0) / column.blocks.length;
                
                // Check if the other column has a single tall block
                const otherColumn = columns.find(c => c !== column);
                const hasSpanningBlock = otherColumn && otherColumn.blocks.length === 1 && 
                                       otherColumn.blocks[0].height > avgBlockHeight * 1.5;
                
                if (hasSpanningBlock && column.blocks.length >= 2) {
                    // Create invisible parent for this column's blocks
                    const invisibleParentId = `InvisibleParent${invisibleParentCounter++}`;
                    const invisibleParent = {
                        id: invisibleParentId,
                        text: '', // Empty text makes it invisible
                        parentId: null,
                        x: Math.min(...column.blocks.map(b => b.x)),
                        y: Math.min(...column.blocks.map(b => b.y)),
                        width: Math.max(...column.blocks.map(b => b.x + b.width)) - Math.min(...column.blocks.map(b => b.x)),
                        height: Math.max(...column.blocks.map(b => b.y + b.height)) - Math.min(...column.blocks.map(b => b.y)),
                        _isInvisibleParent: true
                    };
                    
                    // Set parent relationship for all blocks in this column
                    column.blocks.forEach(block => {
                        block.parentId = invisibleParentId;
                    });
                    
                    // Add invisible parent to results
                    resultBlocks.push(invisibleParent);
                    // Column blocks are now children, they'll be handled by the recursive emission
                } else {
                    // No spanning layout detected, add all blocks as-is
                    resultBlocks.push(...column.blocks);
                }
            }
            
            return resultBlocks;
        }

        function generateMermaidBlockDiagram(blockList) {
            // Accept either a full block list or top-level blocks; normalize to a full list
            let allBlocks = [];
            if (Array.isArray(blockList)) {
                // If caller passed only top-level blocks (no parentId set), prefer the global `blocks`
                // which contains the full diagram so nested children are included.
                const looksLikeTopLevelOnly = blockList.length > 0 && blockList.every(b => !b.parentId);
                if (looksLikeTopLevelOnly && typeof blocks !== 'undefined' && Array.isArray(blocks) && blocks.length > 0) {
                    allBlocks = blocks.slice();
                } else {
                    allBlocks = blockList.slice();
                }
            }
            
            // Find top-level blocks (those with no parentId)
            let topLevel = allBlocks.filter(b => !b.parentId);

            // Detect vertical span layouts and create invisible parent blocks
            topLevel = detectAndCreateVerticalSpans(topLevel);
            
            // Update allBlocks to include any new invisible parent blocks
            const invisibleParents = topLevel.filter(b => b._isInvisibleParent);
            allBlocks = [...allBlocks, ...invisibleParents];
            
            const byId = new Map(allBlocks.map(b => [b.id, b]));

            // Infer unit pixel width for span inference when block.blockWidth is not set
            // Use median block width so a single very wide or very narrow block doesn't skew the column inference
            const pixelWidths = allBlocks.map(b => b.width || 0).filter(w => w > 0);
            const unit = pixelWidths.length > 0 ? (function(){ const a = pixelWidths.slice().sort((x,y)=>x-y); const m = Math.floor(a.length/2); return (a.length % 2 === 1) ? a[m] : Math.round((a[m-1] + a[m]) / 2); })() : 100;

            function spanFor(block) {
                if (block.blockWidth && Number.isFinite(block.blockWidth)) return Math.max(1, block.blockWidth);
                if (block.width && unit > 0) return Math.max(1, Math.round(block.width / unit));
                return 1;
            }

            function escapeLabel(s) {
                if (!s && s !== '') return '';
                return s.replace(/"/g, '\\"');
            }

            function emitBlockRecursive(b, indent = '  ') {
                const children = allBlocks.filter(x => x.parentId === b.id);
                const lines = [];
                if (children.length > 0) {
                    // Start parent block (colors will be handled via classDef/class statements)
                    
                    // For invisible parents, don't emit a label (empty text)
                    const label = (b.text && !b._isInvisibleParent) ? `["${escapeLabel(b.text)}"]` : '';
                    
                    lines.push(`${indent}block:${b.id}${label}`);
                    for (const child of children) {
                        lines.push(emitBlockRecursive(child, indent + '  '));
                    }
                    lines.push(`${indent}end`);
                } else {
                    const span = spanFor(b);
                    const label = b.text ? `["${escapeLabel(b.text)}"]` : '';
                    // Colors will be handled via classDef/class statements
                    lines.push(`${indent}${b.id}${span > 1 ? `:${span}` : ''}${label}`);
                }
                return lines.join('\n');
            }

            // Build output
            // If parsed blocks included a `columns N` directive, treat that as a
            // minimum baseline for round-trip fidelity. However, if user layout
            // changes (for example by inserting explicit space or moving blocks),
            // allow the inferred column count to increase beyond the original so
            // the emitted diagram reflects the visible spacing. We compute both
            // the original (if any) and the inferred value and use the max.
            let originalColumns = null;
            if (topLevel.length > 0 && typeof topLevel[0]._diagramColumns === 'number') {
                originalColumns = Math.max(...topLevel.map(b => b._diagramColumns || 0));
            }

            let columns = null;

            if (!originalColumns || originalColumns <= 0) {
                const rowTolerance = 40; // px tolerance to group blocks into the same row
                const rows = [];
                for (const b of topLevel) {
                    let placed = false;
                    for (const r of rows) {
                        if (Math.abs(r.y - b.y) <= rowTolerance) {
                            r.blocks.push(b);
                            placed = true;
                            break;
                        }
                    }
                    if (!placed) rows.push({ y: b.y, blocks: [b] });
                }

                let maxRowSpan = 1;
                // DEBUG: show top-level items and how they are bucketed into rows
                console.log('DEBUG: topLevel =>', topLevel.map(b => ({ id: b.id, x: b.x, y: b.y })));
                console.log('DEBUG: initial rows =>', rows.map(r => ({ y: r.y, ids: r.blocks.map(b => b.id) })));
                for (const r of rows) {
                    let rowSum = 0;
                    for (const b of r.blocks) rowSum += spanFor(b);
                    maxRowSpan = Math.max(maxRowSpan, rowSum);
                }

                console.log('DEBUG: computed maxRowSpan =', maxRowSpan);
                columns = Math.max(1, Math.round(maxRowSpan));

                // Additionally infer required columns from the actual X positions
                // so explicit visual gaps (ghost spaces on the canvas) are preserved
                // in the textual output. We simulate placing blocks using pixel->col
                // mapping and include gap columns between blocks when needed.
                try {
                    const globalMinX_est = topLevel.length > 0 ? Math.min(...topLevel.map(b => b.x)) : 0;
                    const columnPixelWidth_est = unit > 0 ? unit : 100;
                    let neededColumnsFromGaps = 0;
                    for (const r of rows) {
                        const blocksInRow = r.blocks.slice().sort((a,b)=>a.x - b.x);
                        let currentColSim = 0;
                        for (const b of blocksInRow) {
                            const approxCol = Math.max(0, Math.round((b.x - globalMinX_est) / columnPixelWidth_est));
                            const gapCols = Math.max(0, approxCol - currentColSim);
                            const span = spanFor(b);
                            currentColSim += gapCols + Math.max(1, span);
                        }
                        neededColumnsFromGaps = Math.max(neededColumnsFromGaps, currentColSim);
                    }
                    // Use neededColumnsFromGaps as another inference source
                    columns = Math.max(columns, Math.max(1, Math.round(neededColumnsFromGaps)));
                    console.log('DEBUG: inferred columns from gaps =', neededColumnsFromGaps, '-> using columns =', columns);
                } catch (e) {
                    // Non-fatal; continue with previous columns
                }
            }

            // Ensure we honor the original parsed `columns N` as a minimum baseline
            if (originalColumns && originalColumns > 0) {
                columns = Math.max(columns || 1, originalColumns);
            }

            let out = ['block', `columns ${columns}`];
            // Emit top-level blocks. Prefer to emit rows as inline token lines (so we can emit 'space' tokens)
            // when a row contains only leaf blocks (no children). If a row contains parent blocks,
            // fall back to the recursive emitter which handles nested 'block:ID ... end' sections.
            const rows = [];
            const rowTolerance = 40; // px tolerance to group blocks into the same row
            for (const b of topLevel) {
                let placed = false;
                for (const r of rows) {
                    if (Math.abs(r.y - b.y) <= rowTolerance) { r.blocks.push(b); placed = true; break; }
                }
                if (!placed) rows.push({ y: b.y, blocks: [b] });
            }

            // Infer required columns from actual pixel gaps between blocks so visible
            // ghost spaces on the canvas are preserved in emitted textual output.
            try {
                const globalMinX_emit = topLevel.length > 0 ? Math.min(...topLevel.map(b => b.x)) : 0;
                const columnPixelWidth_emit = unit > 0 ? unit : 100;
                let neededColumnsFromGapsEmit = 0;
                for (const r of rows) {
                    const blocksInRow = r.blocks.slice().sort((a,b)=>a.x - b.x);
                    let currentColSim = 0;
                    for (const b of blocksInRow) {
                        const approxCol = Math.max(0, Math.round((b.x - globalMinX_emit) / columnPixelWidth_emit));
                        const gapCols = Math.max(0, approxCol - currentColSim);
                        const span = spanFor(b);
                        currentColSim += gapCols + Math.max(1, span);
                    }
                    neededColumnsFromGapsEmit = Math.max(neededColumnsFromGapsEmit, currentColSim);
                }
                columns = Math.max(columns || 1, Math.max(1, Math.round(neededColumnsFromGapsEmit)));
                console.log('DEBUG: columns after gap-inference =', columns);
                // Ensure the output header reflects the possibly-updated columns
                out[1] = `columns ${columns}`;
            } catch (e) { /* ignore */ }

            // Helper to emit a token for a single block (leaf or parent token)
            function tokenForBlock(b) {
                if (!b) return '';
                if (allBlocks.some(x => x.parentId === b.id)) {
                    // Parent token (emit as block:ID label) - children will be emitted inline via recursive emitter
                    const label = (b.text && !b._isInvisibleParent) ? `["${escapeLabel(b.text)}"]` : '';
                    return `block:${b.id}${label}`;
                } else {
                    const span = spanFor(b);
                    const label = b.text ? `["${escapeLabel(b.text)}"]` : '';
                    return `${b.id}${span > 1 ? `:${span}` : ''}${label}`;
                }
            }

            // Overall left-most x used for gap calculations (pixel coordinate)
            const globalMinX = topLevel.length > 0 ? Math.min(...topLevel.map(b => b.x)) : 0;
            const columnPixelWidth = unit > 0 ? unit : 100; // pixel width corresponding to one column

            for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                const r = rows[rowIdx];
                const blocksInRow = r.blocks.slice().sort((a,b)=>a.x - b.x);
                const rowHasParents = blocksInRow.some(b => allBlocks.some(x => x.parentId === b.id));
                if (!rowHasParents) {
                    // Build an inline token line with 'space' tokens for gaps using column indices
                    const tokens = [];
                    let currentColIndex = 0;

                    for (const b of blocksInRow) {
                        // Map the block's x position to an approximate column index
                        // Map block x -> column index using floor-based mapping with a small bias
                        // Map block x -> column index using rounding (more stable than biased floor)
                        // Map block x -> column index using rounding and clamp to last column
                        let approxCol = Math.max(0, Math.round((b.x - globalMinX) / columnPixelWidth));
                        if (typeof columnsLocal === 'number' && columnsLocal > 0) approxCol = Math.min(columnsLocal - 1, approxCol);
                        let gapCols = Math.max(0, approxCol - currentColIndex);
                        // Clamp gapCols so we don't exceed total columns
                        if (currentColIndex + gapCols > columns) gapCols = Math.max(0, columns - currentColIndex);

                        // Reserve room for the block so emitting a preceding 'space' doesn't
                        // push the row over the column limit when we later emit the block.
                        // Compute desired span for this block and limit gapCols so that
                        // currentColIndex + gapCols + desiredSpan <= columns (best-effort).
                        const desiredSpan = spanFor(b);
                        const maxAllowGap = Math.max(0, columns - currentColIndex - Math.min(desiredSpan, columns));
                        if (gapCols > maxAllowGap) gapCols = maxAllowGap;

                        if (gapCols > 0) {
                            const spaces = Math.max(1, gapCols);
                            tokens.push(`space${spaces>1?`:${spaces}`:''}`);
                            currentColIndex += spaces;
                        }

                        // Emit the block token with its span, but clamp span to remaining columns
                        const remaining = Math.max(0, columns - currentColIndex);
                        let span;
                        if (remaining <= 0) {
                            // No explicit remaining columns, but prefer emitting visible blocks.
                            // Place the block in the last column with span=1 (best-effort).
                            span = 1;
                            // If columns is defined, set currentColIndex to columns - 1 to reflect placement
                            if (typeof columns === 'number' && columns > 0) currentColIndex = Math.max(0, columns - 1);
                        } else {
                            span = Math.min(spanFor(b), remaining);
                        }
                        // Build token; tokenForBlock would include original span, but we need to ensure
                        // the emitted token uses the possibly-clamped span. Reconstruct token here.
                        if (allBlocks.some(x => x.parentId === b.id)) {
                            const label = (b.text && !b._isInvisibleParent) ? `["${escapeLabel(b.text)}"]` : '';
                            tokens.push(`block:${b.id}${label}`);
                        } else {
                            const label = b.text ? `["${escapeLabel(b.text)}"]` : '';
                            tokens.push(`${b.id}${span>1?`:${span}`:''}${label}`);
                        }
                        currentColIndex += span;
                        // If we've filled the row, stop emitting further tokens for this row
                        if (currentColIndex >= columns) break;
                    }

                    // Pad non-final rows so the sum of token spans equals the total columns
                    const isLastRow = (rowIdx === rows.length - 1);
                    if (!isLastRow && currentColIndex < columns) {
                        const remaining = columns - currentColIndex;
                        tokens.push(`space${remaining>1?`:${remaining}`:''}`);
                        currentColIndex += remaining;
                    }

                    out.push('  ' + tokens.join(' '));
                } else {
                    // Fallback: emit each top-level block recursively in order
                    for (const b of blocksInRow) out.push(emitBlockRecursive(b));
                }
            }
            
            // Add connections/arrows
            if (typeof connections !== 'undefined' && connections.length > 0) {
                out.push(''); // Empty line before connections
                connections.forEach(conn => {
                    const arrowType = conn.arrowType || '-->';
                    if (conn.label && conn.label.trim()) {
                        out.push(`  ${conn.from} -- "${conn.label}" ${arrowType} ${conn.to}`);
                    } else {
                        out.push(`  ${conn.from} ${arrowType} ${conn.to}`);
                    }
                });
            }
            
            // Add classDef and class statements for colors
            const colorMap = new Map();
            let colorCounter = 1;
            
            // Collect all blocks with colors
            const coloredBlocks = allBlocks.filter(b => b.color);
            
            if (coloredBlocks.length > 0) {
                out.push(''); // Empty line before styling
                
                // Generate classDef statements for unique colors
                coloredBlocks.forEach(block => {
                    const color = block.color.startsWith('#') ? block.color : '#' + block.color;
                    if (!colorMap.has(color)) {
                        const className = `color${colorCounter++}`;
                        colorMap.set(color, className);
                        out.push(`  classDef ${className} fill:${color},stroke:#333,stroke-width:2px;`);
                    }
                });
                
                // Generate class statements to assign blocks to color classes
                coloredBlocks.forEach(block => {
                    const color = block.color.startsWith('#') ? block.color : '#' + block.color;
                    const className = colorMap.get(color);
                    if (className) {
                        out.push(`  class ${block.id} ${className}`);
                    }
                });
            }
            
            return out.join('\n') + '\n';
        }

        loadConfirmBtn.addEventListener('click', () => {
            const input = loadInput.value.trim();
            if (!input) {
                loadError.innerText = "Input cannot be empty.";
                loadError.classList.remove('hidden');
                return;
            }
            try {
                const { title, blocks: newBlocks, connections: newConnections } = parseBlockDiagramInput(input);
                // Snap loaded blocks to the app grid so they align to the squares
                // Snap down to nearest grid cell (floor) so blocks align without growing unexpectedly
                const snapFloor = v => Math.floor(v / gridSize) * gridSize;
                newBlocks.forEach(b => {
                    if (typeof b.x === 'number') b.x = snapFloor(b.x);
                    if (typeof b.y === 'number') b.y = snapFloor(b.y);
                    if (typeof b.width === 'number') b.width = Math.max(gridSize, Math.floor(b.width / gridSize) * gridSize);
                    if (typeof b.height === 'number') b.height = Math.max(gridSize, Math.floor(b.height / gridSize) * gridSize);
                });

                diagramTitleInput.value = title;
                blocks = newBlocks;
                connections = (newConnections || []).map(c => ({ _id: c._id || `conn${connectionCounter++}`, from: c.from, to: c.to, label: c.label || '' }));
                selectedBlocks.clear();
                draw();
                updateMarkdown();
                // Scroll to fit newly loaded diagram so users can see all blocks
                scrollCanvasToFitBlocks();
                loadModal.classList.add('hidden');
            } catch (error) {
                console.error("Parsing error:", error);
                loadError.innerText = error.message;
                loadError.classList.remove('hidden');
            }
        });

        // Scroll the canvas container so the bounding box of blocks is centered in view
        function scrollCanvasToFitBlocks() {
            try {
                if (!blocks || blocks.length === 0) return;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const b of blocks) {
                    if (typeof b.x === 'number') minX = Math.min(minX, b.x);
                    if (typeof b.y === 'number') minY = Math.min(minY, b.y);
                    if (typeof b.x === 'number' && typeof b.width === 'number') maxX = Math.max(maxX, b.x + b.width);
                    if (typeof b.y === 'number' && typeof b.height === 'number') maxY = Math.max(maxY, b.y + b.height);
                }
                if (!isFinite(minX) || !isFinite(minY)) return;
                const boxWidth = Math.max(1, maxX - minX);
                const boxHeight = Math.max(1, maxY - minY);
                const centerX = minX + boxWidth / 2;
                const centerY = minY + boxHeight / 2;
                // Scroll container so centerX/centerY are centered in viewport
                const targetScrollLeft = Math.max(0, Math.floor(centerX - canvasContainer.clientWidth / 2));
                const targetScrollTop = Math.max(0, Math.floor(centerY - canvasContainer.clientHeight / 2));
                canvasContainer.scrollLeft = targetScrollLeft;
                canvasContainer.scrollTop = targetScrollTop;
            } catch (e) { /* ignore */ }
        }


        // --- TEST HARNESS ---
        function runRoundTripTest() {
            console.log('🧪 Starting Round-Trip Test...');
            
            // Test cases
            const testCases = [
                {
                    name: 'Simple blocks',
                    input: `block
columns 3
  A["Frontend"]
  B["Backend"]
  C["Database"]`
                },
                {
                    name: 'Two column layout',
                    input: `block
columns 2
  A["Top Left"]
  B["Top Right"]
  C["Bottom Left"]
  D["Bottom Right"]`
                },
                {
                    name: 'Nested blocks with multiple children',
                    input: `block
columns 1
  block:block1
    block2["Inner 1"]
    block3["Inner 2"]
  end`
                },
                {
                    name: 'Nested blocks (original test)',
                    input: `block
columns 1
  D
  block:ID
    A
    B["A wide one in the middle"]
    C
  end`
                },
                {
                    name: 'Layout with spaces',
                    input: `block
columns 3
  A["Left"]
  space
  C["Right"]
  space
  B["Center"]
  space`
                },
                {
                    name: 'Blocks with connections',
                    input: `block
columns 2
  Frontend
  Backend
  Frontend --> Backend`
                },
                {
                    name: 'Blocks with labeled connections',
                    input: `block
columns 2
  API
  Database  
  API --> |"queries"| Database`
                }
            ];
            
            testCases.forEach((testCase, index) => {
                console.log(`\n--- Test ${index + 1}: ${testCase.name} ---`);
                console.log('Input:', testCase.input);
                
                try {
                    // Step 1: Parse input into blocks
                    const { title, blocks: parsedBlocks, connections: parsedConnections } = parseBlockDiagramInput(testCase.input);
                    console.log('✅ Parsing successful');
                    console.log('Parsed blocks with positions:');
                    parsedBlocks.forEach(b => {
                        console.log(`  - ${b.id}: "${b.text}" at (${b.x}, ${b.y}) parent: ${b.parentId || 'none'}`);
                    });
                    
                    // Step 2: Simulate the blocks being loaded
                    const originalBlocks = [...blocks];
                    const originalConnections = [...connections];
                    blocks = parsedBlocks;
                    connections = parsedConnections || [];
                    
                    // Step 3: Generate output from those blocks
                    const output = generateMermaidBlockDiagram(parsedBlocks);
                    console.log('Generated output:', output);
                    
                    // Step 4: Parse the generated output back
                    const { blocks: reparsedBlocks, connections: reparsedConnections } = parseBlockDiagramInput(output);
                    console.log('✅ Re-parsing successful, blocks:', reparsedBlocks.map(b => ({ id: b.id, text: b.text, parentId: b.parentId })));
                    
                    // Step 5: Compare structures
                    const originalStructure = parsedBlocks.map(b => ({ id: b.id, text: b.text, parentId: b.parentId }));
                    const reparsedStructure = reparsedBlocks.map(b => ({ id: b.id, text: b.text, parentId: b.parentId }));
                    
                    const structuresMatch = JSON.stringify(originalStructure.sort((a,b) => a.id.localeCompare(b.id))) === 
                                          JSON.stringify(reparsedStructure.sort((a,b) => a.id.localeCompare(b.id)));
                    
                    if (structuresMatch) {
                        console.log('✅ Round-trip successful!');
                    } else {
                        console.log('❌ Round-trip failed - structures differ');
                        console.log('Original:', originalStructure);
                        console.log('Reparsed:', reparsedStructure);
                    }
                    
                    // Restore original state
                    blocks = originalBlocks;
                    connections = originalConnections;
                    
                } catch (error) {
                    console.error('❌ Test failed:', error);
                    blocks = originalBlocks;
                }
            });
            
            console.log('\n🏁 Round-trip tests completed!');
        }
        
        // // Add test button to UI (temporary)
        // document.addEventListener('DOMContentLoaded', () => {
        //     const testBtn = document.createElement('button');
        //     testBtn.innerText = '🧪 Run Tests';
        //     testBtn.className = 'test-button';
        //     testBtn.onclick = () => {
        //         console.clear();
        //         runRoundTripTest();
        //         alert('Test results in console (F12)');
        //     };
        //     document.body.appendChild(testBtn);
        // });

    // --- INITIALIZATION ---
    window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>




