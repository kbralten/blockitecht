<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockitect - Mermaid Block Diagram Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Basic layout and utility styles to replace Tailwind */
        :root{
            --bg: #f3f4f6; /* gray-100 */
            --text: #1f2937; /* gray-800 */
            --muted: #6b7280; /* gray-500 */
            --panel-bg: #ffffff;
            --primary: #2563eb; /* blue-600 */
            --primary-600: #1d4ed8;
            --danger: #ef4444;
            --success: #16a34a;
            --purple: #7c3aed;
        }
        html,body,#app{height:100%;}
        body{background:var(--bg);color:var(--text);margin:0}

        .app-root{display:flex;flex-direction:column;height:100vh}
        header.app-header{background:var(--panel-bg);box-shadow:0 1px 3px rgba(0,0,0,0.06);padding:12px 16px;display:flex;justify-content:space-between;align-items:center}
        .header-left{display:flex;align-items:center;gap:12px}
        .header-left h1{font-size:1.25rem;margin:0;font-weight:700}
        input.title-input{padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;outline:none;width:16rem}
        input.title-input:focus{box-shadow:0 0 0 3px rgba(37,99,235,0.12);border-color:var(--primary)}

        .header-actions{display:flex;align-items:center;gap:8px}
        .btn{border:none;padding:8px 12px;border-radius:8px;color:white;font-weight:600;cursor:pointer}
        .btn.secondary{background:#6b7280}
        .btn.primary{background:var(--primary)}
        .btn.ghost{background:transparent;color:var(--text);border:1px solid transparent}
        .btn.danger{background:var(--danger)}
        .btn.purple{background:var(--purple)}
        .btn:disabled{opacity:0.6;cursor:not-allowed}

        main.app-main{display:flex;flex:1;padding:16px;gap:16px;overflow:hidden}
        .panel{background:var(--panel-bg);border-radius:12px;box-shadow:0 6px 18px rgba(15,23,42,0.06);display:flex;flex-direction:column;overflow:hidden}
        .panel .panel-header{padding:8px 12px;border-bottom:1px solid #e5e7eb}
        .panel .panel-body{padding:8px;flex:1;overflow:auto}

        .canvas-panel{flex:1;display:flex;flex-direction:column}
        #canvas-container{position:relative;flex:1;overflow:auto}
        canvas#canvas{position:absolute;top:0;left:0}
        textarea#text-editor{position:absolute;z-index:10;display:none}

        .md-panel{width:33%;min-width:220px;display:flex;flex-direction:column}
        textarea#markdown-output{width:100%;height:100%;padding:8px;border:0;border-radius:6px;background:#f8fafc;font-family:monospace;font-size:0.85rem}

        /* Grid background (kept from original) */
        .grid-bg {
            background-image:
                linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .context-menu {
            display: none;
            position: absolute;
            z-index: 1000;
            background: var(--panel-bg);
            border:1px solid #d1d5db;
            border-radius:8px;
            box-shadow:0 8px 24px rgba(0,0,0,0.08);
            min-width:180px;
            padding:4px 4px;
        }
        .context-menu.show { display:block }
        .context-menu button{background:transparent;border:none;padding:8px 10px;width:100%;text-align:left;cursor:pointer;border-radius:6px}
        .context-menu button:hover{background:#f3f4f6}
        /* Modal Styles */
        .modal-overlay {
            position: fixed;inset:0;background-color:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:2000;padding:16px
        }
        .modal-content{background:var(--panel-bg);padding:16px;border-radius:10px;width:min(720px,100%);box-shadow:0 10px 25px rgba(0,0,0,0.12)}
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        /* Reused UI classes to replace inline styles */
        .panel-title { margin:0; font-size:1rem; font-weight:600; }
        .text-editor { z-index:10; }

        .modal-header-row { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
        .modal-title { font-size:1.125rem; font-weight:700; margin:0 }
        .modal-close { background:transparent; border:none; font-size:1.25rem; cursor:pointer }
        .color-swatches { display:flex; flex-wrap:wrap; gap:8px }
        .modal-footer-right { display:flex; justify-content:flex-end; margin-top:12px }

        .input-label { display:block; font-size:0.9rem; color:var(--muted) }
        .load-footer { display:flex; justify-content:flex-end; align-items:center; margin-top:16px; padding-top:12px; border-top:1px solid #e5e7eb }
        .error-text { color:var(--danger); font-size:0.9rem; margin-top:8px; text-align:right }

        /* Color swatch styles */
        .color-swatch {
            width: 34px;
            height: 34px;
            border-radius: 6px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .color-swatch:hover {
            transform: scale(1.06);
        }
        .color-swatch.selected {
            border-color: #111 !important;
            box-shadow: 0 0 0 2px rgba(17, 24, 39, 0.2);
        }
        .color-swatch.clear {
            background: transparent;
            border-color: #9CA3AF;
            color: #374151;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

    /* Color HUD (small swatches near selected block) */
    .color-hud { position: absolute; display:flex; gap:8px; padding:6px; background: rgba(255,255,255,0.96); border:1px solid #e5e7eb; border-radius:8px; box-shadow:0 8px 20px rgba(15,23,42,0.08); z-index:1500; }
    .color-hud.hidden { display:none }
    .color-hud .sw { width:28px; height:28px; border-radius:6px; border:2px solid transparent; cursor:pointer; box-sizing:border-box; transition: all 0.15s ease; }
    .color-hud .sw:focus { outline:2px solid rgba(0,0,0,0.08) }
    .color-hud .sw:hover { transform: scale(1.06) }
    .color-hud .sw.current { border-color: #111; box-shadow: 0 0 0 1px rgba(17, 24, 39, 0.3); }
    .color-hud .clear-swatch { background: transparent; border-color: #9CA3AF; color: #374151; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; }
    .color-hud .color-swatch-hud { border: 2px solid transparent; }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Minimal Tailwind-like utility fallbacks used in the markup */
        .hidden{display:none!important}
        .flex{display:flex}
        .block{display:block}
        .items-center{align-items:center}
        .justify-between{justify-content:space-between}
        .text-left{text-align:left}
        .text-right{text-align:right}
        .text-center{text-align:center}

        .w-full{width:100%}
        .h-24{height:6rem}
        .h-32{height:8rem}
        .h-48{height:12rem}

        .px-4{padding-left:1rem;padding-right:1rem}
        .py-2{padding-top:0.5rem;padding-bottom:0.5rem}
        .p-2{padding:0.5rem}
        .p-1{padding:0.25rem}
        .p-4{padding:1rem}
        .pt-4{padding-top:1rem}
        .mb-4{margin-bottom:1rem}
        .mt-6{margin-top:1.5rem}
        .mt-2{margin-top:0.5rem}
        .space-y-4 > * + *{margin-top:1rem}
        .space-x-2 > * + *{margin-left:0.5rem}
        .space-x-4 > * + *{margin-left:1rem}

        .border{border:1px solid #e5e7eb}
        .border-t{border-top:1px solid #e5e7eb}
        .border-2{border-width:2px}
        .border-gray-300{border-color:#d1d5db}
        .bg-white{background:#ffffff}
        .bg-gray-50{background:#f9fafb}
        .bg-gray-100{background:#f3f4f6}

        .rounded-md{border-radius:6px}
        .rounded-lg{border-radius:8px}
        .shadow-lg{box-shadow:0 8px 24px rgba(0,0,0,0.08)}

        .text-sm{font-size:0.875rem}
        .text-xl{font-size:1.25rem}
        .font-bold{font-weight:700}
        .font-medium{font-weight:500}
        .font-mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace}
        .font-sans{font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}

        .text-gray-700{color:#374151}
        .text-gray-500{color:#6b7280}
        .text-red-600{color:#dc2626}
        .text-red-500{color:#ef4444}
        .text-white{color:#fff}

        .hover\:bg-gray-100:hover{background:#f3f4f6}
        .hover\:bg-gray-600:hover{background:#4b5563}
        .hover\:bg-blue-700:hover{background:#1d4ed8}
        .hover\:bg-green-700:hover{background:#15803d}
        .hover\:bg-purple-700:hover{background:#6d28d9}
        .hover\:text-gray-800:hover{color:#1f2937}

        .transition{transition:all 0.15s ease}
        .overflow-y-auto{overflow-y:auto}
        .resize-none{resize:none}
        .focus\:outline-none:focus{outline:none}

    </style>
</head>
<body>
    <div class="app-root" id="app">
        <header class="app-header">
            <div class="header-left">
                <h1>Blockitect</h1>
                <input type="text" id="diagram-title" placeholder="Enter Diagram Title" class="title-input">
            </div>
            <div class="header-actions">
                <button id="load-markdown" class="btn secondary">Load Block Diagram</button>
                <button id="clear-canvas" class="btn danger">Clear Canvas</button>
                <button id="copy-markdown" class="btn primary">Copy Mermaid</button>
                <button id="clear-styles" class="btn purple">Clear styles</button>
                <button id="fit-diagram" class="btn ghost">Fit Diagram</button>
            </div>
        </header>

        <main class="app-main">
            <!-- Canvas Area -->
            <div class="panel canvas-panel">
                <div class="panel-header">
                    <h2 class="panel-title">Diagram Canvas</h2>
                </div>
                <div id="canvas-container" class="panel-body grid-bg">
                    <canvas id="canvas"></canvas>
                    <textarea id="text-editor" class="text-editor"></textarea>
                    <!-- Color HUD: appears near selected block for quick swatches -->
                    <div id="color-hud" class="color-hud hidden" aria-hidden="true"></div>
                </div>
            </div>

            <!-- Mermaid Block Diagram Output -->
            <div class="panel md-panel">
                 <div class="panel-header"><h2 class="panel-title">Mermaid Block Diagram</h2></div>
                <div class="panel-body">
                    <textarea id="markdown-output" readonly title="Generated Mermaid block diagram code"></textarea>
                </div>
            </div>
        </main>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="context-menu">
        <button id="split-h">Split Horizontally</button>
        <button id="split-v">Split Vertically</button>
        <button id="merge">Merge Blocks</button>
    <button id="delete" class="text-red-500">Delete Block</button>
    </div>

    <!-- Color Palette Modal removed - HUD is used for color changes -->

    <!-- AI features removed -->
    
    <!-- Load Block Diagram Modal -->
    <div id="load-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-header-row">
                <h2 class="modal-title">Load Block Diagram</h2>
                <button id="close-load-modal" class="modal-close">&times;</button>
            </div>
            <div>
                <label for="load-input" class="input-label">Paste your Mermaid block diagram here:</label>
                <textarea id="load-input" class="w-full h-48 p-2 border border-gray-300 rounded-lg mt-1 font-mono text-sm" placeholder="block&#10;columns 3&#10;  A&#10;  B&#10;  C"></textarea>
            </div>
            <div class="load-footer">
                <button id="load-confirm-btn" class="btn primary">Load Diagram</button>
            </div>
            <p id="load-error" class="error-text hidden"></p>
        </div>
    </div>


    <script>
        // --- DOM ELEMENT REFERENCES ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');
        const markdownOutput = document.getElementById('markdown-output');
        const copyMarkdownBtn = document.getElementById('copy-markdown');
        const clearCanvasBtn = document.getElementById('clear-canvas');
    const fitDiagramBtn = document.getElementById('fit-diagram');
        const diagramTitleInput = document.getElementById('diagram-title');
        const textEditor = document.getElementById('text-editor');

        const contextMenu = document.getElementById('context-menu');
        const splitHBtn = document.getElementById('split-h');
        const splitVBtn = document.getElementById('split-v');
        const mergeBtn = document.getElementById('merge');
        const deleteBtn = document.getElementById('delete');

    // AI elements removed

        const loadModal = document.getElementById('load-modal');
        const loadMarkdownBtn = document.getElementById('load-markdown');
        const closeLoadModalBtn = document.getElementById('close-load-modal');
        const loadInput = document.getElementById('load-input');
        const loadConfirmBtn = document.getElementById('load-confirm-btn');
        const loadError = document.getElementById('load-error');

        // --- STATE VARIABLES ---
        const gridSize = 20;
        let blocks = [];
    // Disable autosave during initialization to avoid overwriting existing storage with empty state
    let autosaveEnabled = false;
        let selectedBlocks = new Set();
        let currentBlock = null, editingBlock = null, activeContextMenuBlock = null;
        let drawing = false, dragging = false, resizing = false;
        let startX, startY, dragOffsetX, dragOffsetY, resizeHandle;
        let dragStartStates = new Map();

        // AI features removed

    // --- Color Presets ---
    // Pleasant pastel palette (12 colors), rearranged to alternate hues (blue, green, orange/pink, ...)
    // Stored without the leading '#'.
    const presetColors = ['93C5FD','7DD3A6','FDE68A',  // light blue, light green, light orange
                           '60A5FA','86EFAC','FCA5A5',  // mid blue, mid green, pink
                           '7DD3FC','BBF7D0','FCD34D',  // cyan, mint, orange
                           'C7B8FF','DBEAFE','FDA4FF']; // lavender, pale indigo, magenta

    // --- Friendly Name Generation ---
    // Generate human-readable block IDs instead of GUIDs
    let blockCounter = 1;
    const friendlyNames = [
        'Task', 'Process', 'Step', 'Action', 'Goal', 'Feature', 'Component', 'Service', 'Module', 'System',
        'Input', 'Output', 'Data', 'Flow', 'Logic', 'Control', 'Interface', 'Handler', 'Manager', 'Provider',
        'Builder', 'Factory', 'Helper', 'Utility', 'Container', 'Wrapper', 'Router', 'Filter', 'Parser', 'Validator',
        'Model', 'View', 'Controller', 'Config', 'Settings', 'Options', 'Params', 'Context', 'State', 'Store',
        'Queue', 'Stack', 'Cache', 'Buffer', 'Pool', 'Registry', 'Catalog', 'Index', 'Database', 'Repository'
    ];
    
    function generateFriendlyId() {
        // Try friendly names first, then fall back to numbered blocks
        if (blockCounter <= friendlyNames.length) {
            const name = friendlyNames[blockCounter - 1];
            blockCounter++;
            
            // Ensure uniqueness - if name already exists, add a number
            const baseName = name;
            let suffix = '';
            let counter = 1;
            while (blocks.some(b => b.id === (baseName + suffix))) {
                suffix = counter.toString();
                counter++;
            }
            return baseName + suffix;
        } else {
            // Fall back to Block1, Block2, etc.
            let id = `Block${blockCounter}`;
            while (blocks.some(b => b.id === id)) {
                blockCounter++;
                id = `Block${blockCounter}`;
            }
            blockCounter++;
            return id;
        }
    }

    // --- Color UI & Logic ---
    // Modal-based color picker removed; HUD provides quick color changes.
    const clearStylesBtn = document.getElementById('clear-styles');

    // Clear all colors from every block and persist the change
    if (clearStylesBtn) {
        clearStylesBtn.addEventListener('click', () => {
            if (!blocks || blocks.length === 0) return;
            for (const b of blocks) { if (b && b.color) delete b.color; }
            draw(); updateMarkdown();
            // Also persist immediately
            saveCanvasState();
        });
    }

    // Assign colors to a block and its descendants in BFS order using successive palette colors
    function assignColorsToTree(rootBlock, startIdx) {
        const queue = [{ node: rootBlock, depth: 0 }];
        const visited = new Set();
        while (queue.length > 0) {
            const { node, depth } = queue.shift();
            if (!node || visited.has(node.id)) continue;
            visited.add(node.id);
            const color = presetColors[(startIdx + depth) % presetColors.length];
            node.color = '#' + color;
            // enqueue children
            const children = blocks.filter(b => b.parentId === node.id);
            children.forEach(c => queue.push({ node: c, depth: depth + 1 }));
        }
    }

    // Remove color property from a block and all its descendants
    function clearColorsFromTree(rootBlock) {
        if (!rootBlock) return;
        const descendants = getDescendants(rootBlock, blocks, true);
        descendants.forEach(b => { if (b && b.color) delete b.color; });
    }


        // --- HELPER & HIERARCHY FUNCTIONS ---
        const getBlockById = id => blocks.find(b => b.id === id);
        const getParent = block => block?.parentId ? getBlockById(block.parentId) : null;
        
        function getDepth(block) {
            let depth = 0;
            let p = getParent(block);
            while (p) { depth++; p = getParent(p); }
            return depth;
        }

        const getTopBlockAtPos = (pos) => {
            const clickedBlocks = blocks.filter(b => pos.x >= b.x && pos.x <= b.x + b.width && pos.y >= b.y && pos.y <= b.y + b.height);
            return clickedBlocks.length > 0 ? clickedBlocks.sort((a, b) => getDepth(a) - getDepth(b)).pop() : null;
        };
        
        function getDescendants(rootBlock, allBlocks, includeSelf = false) {
            const descendants = includeSelf ? [rootBlock] : [];
            const queue = allBlocks.filter(b => b.parentId === rootBlock.id);
            const visited = new Set(queue.map(b => b.id));
            visited.add(rootBlock.id);
            
            while(queue.length > 0) {
                const current = queue.shift();
                descendants.push(current);
                const children = allBlocks.filter(b => b.parentId === current.id);
                for(const child of children) {
                    if(!visited.has(child.id)) {
                        visited.add(child.id);
                        queue.push(child);
                    }
                }
            }
            return descendants;
        }

        const isAncestor = (ancestor, descendant) => {
            let current = getParent(descendant);
            while (current) {
                if (current.id === ancestor.id) return true;
                current = getParent(current);
            }
            return false;
        };

        // --- DRAWING FUNCTIONS ---
        const resizeCanvas = () => {
            // Start with the visible container size
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            // Ensure canvas fits any blocks that extend beyond the visible area
            ensureCanvasFitsBlocks();
            draw();
        };

        // Expand canvas size to include all blocks' extents (do not shrink below container size)
        function ensureCanvasFitsBlocks() {
            try {
                if (!Array.isArray(blocks) || blocks.length === 0) return;
                const margin = 50;
                let maxRight = 0, maxBottom = 0;
                for (const b of blocks) {
                    const right = (typeof b.x === 'number' ? b.x : 0) + (typeof b.width === 'number' ? b.width : 0);
                    const bottom = (typeof b.y === 'number' ? b.y : 0) + (typeof b.height === 'number' ? b.height : 0);
                    if (right > maxRight) maxRight = right;
                    if (bottom > maxBottom) maxBottom = bottom;
                }
                const desiredWidth = Math.max(canvasContainer.clientWidth, Math.ceil(maxRight + margin));
                const desiredHeight = Math.max(canvasContainer.clientHeight, Math.ceil(maxBottom + margin));
                if (canvas.width < desiredWidth) canvas.width = desiredWidth;
                if (canvas.height < desiredHeight) canvas.height = desiredHeight;
            } catch (e) {
                // ignore errors during sizing
            }
        }
        
        function drawBlocks() {
            const sortedBlocks = [...blocks].sort((a, b) => getDepth(a) - getDepth(b));
            sortedBlocks.forEach(block => {
                const isParent = blocks.some(b => b.parentId === block.id);
                // If block has color, use it; otherwise fallback to existing scheme
                if (block.color) {
                    // fill with color, subtle alpha
                    ctx.fillStyle = hexToRgba(block.color, 0.15);
                    ctx.fillRect(block.x, block.y, block.width, block.height);
                    ctx.strokeStyle = block.color;
                } else {
                    ctx.fillStyle = selectedBlocks.has(block) ? 'rgba(59, 130, 246, 0.3)' : isParent ? 'rgba(16, 185, 129, 0.1)' : 'rgba(59, 130, 246, 0.1)';
                    ctx.fillRect(block.x, block.y, block.width, block.height);
                    ctx.strokeStyle = isParent ? '#059669' : '#3B82F6';
                }
                ctx.lineWidth = 2;
                ctx.strokeRect(block.x, block.y, block.width, block.height);
                // Always use a dark text color because the palette uses light pastels
                ctx.fillStyle = '#111827';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = '14px Inter';
                const lines = (block.text || '').split('\n');
                const startYPos = block.y + 8;
                lines.forEach((line, i) => ctx.fillText(line, block.x + block.width / 2, startYPos + i * 16));
            });
            selectedBlocks.forEach(drawResizeHandles);
        }

    function hexToRgba(hex, alpha) {
        const h = hex.replace('#','');
        const r = parseInt(h.substring(0,2),16);
        const g = parseInt(h.substring(2,4),16);
        const b = parseInt(h.substring(4,6),16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function getContrastingTextColor(bg) {
        try {
            const h = (bg || '#ffffff').replace('#','');
            const r = parseInt(h.substring(0,2),16);
            const g = parseInt(h.substring(2,4),16);
            const b = parseInt(h.substring(4,6),16);
            // Perceptual luminance
            const lum = 0.2126 * (r/255) + 0.7152 * (g/255) + 0.0722 * (b/255);
            return lum > 0.6 ? '#111827' : '#ffffff';
        } catch (e) { return '#111827'; }
    }
    
    // --- Color HUD logic ---
    const colorHud = document.getElementById('color-hud');
    function buildHud() {
        if (!colorHud) return;
        colorHud.innerHTML = '';
        // Clear swatch first
        const clearBtn = document.createElement('button');
        clearBtn.className = 'sw clear-swatch';
        clearBtn.title = 'Clear color';
        clearBtn.innerText = 'Ã—';
        clearBtn.onclick = (e) => { e.stopPropagation(); if (selectedBlocks.size === 0) return; for (const b of [...selectedBlocks]) clearColorsFromTree(b); draw(); updateMarkdown(); };
        colorHud.appendChild(clearBtn);
        presetColors.forEach(hex => {
            const sw = document.createElement('button');
            sw.className = 'sw color-swatch-hud';
            sw.style.backgroundColor = '#' + hex;
            sw.dataset.hex = hex;
            sw.title = '#' + hex;
            sw.onclick = (e) => {
                e.stopPropagation();
                if (selectedBlocks.size === 0) return;
                const baseIdx = presetColors.findIndex(h => h.toLowerCase() === hex.toLowerCase());
                for (const b of [...selectedBlocks]) assignColorsToTree(b, baseIdx >= 0 ? baseIdx : 0);
                draw(); updateMarkdown();
            };
            colorHud.appendChild(sw);
        });
    }

    function updateColorHud() {
        if (!colorHud) return;
        if (selectedBlocks.size === 0) { colorHud.classList.add('hidden'); return; }
        if (!colorHud.hasChildNodes()) buildHud();
        const sel = [...selectedBlocks].sort((a,b)=>getDepth(a)-getDepth(b))[0];
        if (!sel) { colorHud.classList.add('hidden'); return; }
        
        // Highlight current block's color in the HUD
        const swatches = colorHud.querySelectorAll('.sw');
        swatches.forEach(sw => sw.classList.remove('current'));
        
        if (sel.color) {
            // Find matching color swatch
            const targetHex = sel.color.replace('#', '').toLowerCase();
            const matchingSwatch = Array.from(swatches).find(sw => {
                const swatchHex = sw.dataset.hex;
                return swatchHex && swatchHex.toLowerCase() === targetHex;
            });
            if (matchingSwatch) {
                matchingSwatch.classList.add('current');
            }
        }
        
        // Position the HUD relative to the canvas coordinates
        // Keep it inside the canvas container
        const containerRect = canvasContainer.getBoundingClientRect();
        const x = Math.min(Math.max(8, sel.x + sel.width + 12), containerRect.width - 120);
        const y = Math.min(Math.max(8, sel.y), containerRect.height - 40);
        colorHud.style.left = x + 'px';
        colorHud.style.top = y + 'px';
        colorHud.classList.remove('hidden');
    }

    // Hide HUD when clicking outside
    document.addEventListener('click', (e)=>{ if (colorHud && !colorHud.contains(e.target)) { colorHud.classList.add('hidden'); } });

    function drawResizeHandles(block) {
            const size = 8, h = size / 2;
            const {x, y, width, height} = block, midX = x + width/2, midY = y + height/2;
            const handles = [ {x, y}, {x: midX, y}, {x: x+width, y}, {x, y: midY}, {x: x+width, y: midY}, {x, y: y+height}, {x: midX, y: y+height}, {x: x+width, y: y+height}];
            ctx.fillStyle = '#3B82F6';
            handles.forEach(p => ctx.fillRect(p.x - h, p.y - h, size, size));
        }

    function draw() { 
        // Ensure canvas covers all blocks before drawing so nothing is clipped
        ensureCanvasFitsBlocks();
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        drawBlocks(); 
        saveCanvasState(); 
        updateColorHud();
    }
        
        // --- EVENT HANDLERS & LOGIC ---
        const snapToGrid = value => Math.round(value / gridSize) * gridSize;
        const getMousePos = e => { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; };
        
        function isOverResizeHandle(pos, block) {
            if (!selectedBlocks.has(block)) return null;
            const h = 4, {x, y, width, height} = block, midX = x+width/2, midY = y+height/2;
            const inRange = (val, min, max) => val >= min-h && val <= max+h;
            if(inRange(pos.x, x, x) && inRange(pos.y, y, y)) return 'nw';
            if(inRange(pos.x, x+width, x+width) && inRange(pos.y, y, y)) return 'ne';
            if(inRange(pos.x, x, x) && inRange(pos.y, y+height, y+height)) return 'sw';
            if(inRange(pos.x, x+width, x+width) && inRange(pos.y, y+height, y+height)) return 'se';
            if(inRange(pos.x, midX, midX) && inRange(pos.y, y, y)) return 'n';
            if(inRange(pos.x, midX, midX) && inRange(pos.y, y+height, y+height)) return 's';
            if(inRange(pos.x, x, x) && inRange(pos.y, midY, midY)) return 'w';
            if(inRange(pos.x, x+width, x+width) && inRange(pos.y, midY, midY)) return 'e';
            return null;
        }

        function hasOverlap(targetBlock, ignoreSet = new Set()) {
            for (const block of blocks) {
                if (block === targetBlock || ignoreSet.has(block) || isAncestor(targetBlock, block) || isAncestor(block, targetBlock)) continue;
                if (targetBlock.x < block.x + block.width && targetBlock.x + targetBlock.width > block.x && targetBlock.y < block.y + block.height && targetBlock.y + targetBlock.height > block.y) return true;
            }
            return false;
        }

        canvas.addEventListener('mousedown', (e) => {
            hideTextEditor();
            const pos = getMousePos(e);
            dragStartStates.clear();
            let topBlock = getTopBlockAtPos(pos);
            if (topBlock) {
                resizeHandle = isOverResizeHandle(pos, topBlock);
                if (e.button === 2) { e.preventDefault(); activeContextMenuBlock = topBlock; showContextMenu(e.clientX, e.clientY); return; }
                if (resizeHandle) {
                    resizing = true; currentBlock = topBlock;
                    dragStartStates.set(topBlock, { ...topBlock });
                } else {
                    dragging = true; currentBlock = topBlock;
                    if (!e.ctrlKey && !e.shiftKey && !selectedBlocks.has(topBlock)) { selectedBlocks.clear(); selectedBlocks.add(topBlock); }
                    else if (e.ctrlKey || e.shiftKey) { selectedBlocks.has(topBlock) ? selectedBlocks.delete(topBlock) : selectedBlocks.add(topBlock); }
                    dragOffsetX = pos.x - topBlock.x; dragOffsetY = pos.y - topBlock.y;
                    selectedBlocks.forEach(b => dragStartStates.set(b, { ...b }));
                }
            } else {
                if (!e.ctrlKey && !e.shiftKey) selectedBlocks.clear();
                if (e.button !== 2) {
                    drawing = true; startX = snapToGrid(pos.x); startY = snapToGrid(pos.y);
                    currentBlock = { id: generateFriendlyId(), parentId: null, x: startX, y: startY, width: 0, height: 0, text: 'New Block' };
                    blocks.push(currentBlock);
                }
            }
            hideContextMenu(); draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            if (!dragging && !drawing) {
                const topBlock = getTopBlockAtPos(pos);
                let cursor = 'default';
                if(topBlock) {
                    const handle = isOverResizeHandle(pos, topBlock);
                    if (handle) {
                        if (['n', 's'].includes(handle)) cursor = 'ns-resize';
                        else if (['e', 'w'].includes(handle)) cursor = 'ew-resize';
                        else if (['nw', 'se'].includes(handle)) cursor = 'nwse-resize';
                        else cursor = 'nesw-resize';
                    } else cursor = 'move';
                }
                canvas.style.cursor = cursor;
            }

            if (drawing) {
                currentBlock.width = Math.max(gridSize, snapToGrid(pos.x) - startX);
                currentBlock.height = Math.max(gridSize, snapToGrid(pos.y) - startY);
            } else if (dragging) {
                const dx = snapToGrid(pos.x - dragOffsetX) - currentBlock.x;
                const dy = snapToGrid(pos.y - dragOffsetY) - currentBlock.y;
                const allToMove = new Set();
                selectedBlocks.forEach(b => getDescendants(b, blocks, true).forEach(d => allToMove.add(d)));
                allToMove.forEach(b => { b.x += dx; b.y += dy; });
            } else if (resizing) {
                const o = dragStartStates.get(currentBlock), s = {x: snapToGrid(pos.x), y: snapToGrid(pos.y)};
                let {x, y, width, height} = currentBlock;
                if (resizeHandle.includes('w')) { width = o.x + o.width - s.x; if(width >= gridSize) x = s.x; }
                if (resizeHandle.includes('e')) width = s.x - o.x;
                if (resizeHandle.includes('n')) { height = o.y + o.height - s.y; if(height >= gridSize) y = s.y; }
                if (resizeHandle.includes('s')) height = s.y - o.y;
                width = Math.max(gridSize, width); height = Math.max(gridSize, height);
                const children = blocks.filter(b => b.parentId === currentBlock.id);
                if(children.length > 0) {
                    const bounds = children.reduce((a,c) => ({minX:Math.min(a.minX,c.x),minY:Math.min(a.minY,c.y),maxX:Math.max(a.maxX,c.x+c.width),maxY:Math.max(a.maxY,c.y+c.height)}),{minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity});
                    const finalX = resizeHandle.includes('w') ? x : currentBlock.x;
                    const finalY = resizeHandle.includes('n') ? y : currentBlock.y;
                    if (width >= bounds.maxX - finalX) { currentBlock.x = x; currentBlock.width = width; }
                    if (height >= bounds.maxY - finalY) { currentBlock.y = y; currentBlock.height = height; }
                } else { Object.assign(currentBlock, {x, y, width, height}); }
            }
            draw();
        });

        canvas.addEventListener('mouseup', () => {
             if (drawing && (currentBlock.width < gridSize || currentBlock.height < gridSize || hasOverlap(currentBlock))) { blocks.pop(); }
             else if (dragging && currentBlock) {
                let newParent = null;
                const {x, y, width, height} = currentBlock, cX = x + width/2, cY = y + height/2;
                for(const p of blocks.filter(b => b.id !== currentBlock.id && !isAncestor(currentBlock,b))) {
                    if (cX > p.x && cX < p.x + p.width && cY > p.y && cY < p.y + p.height) {
                         if (!newParent || (p.width * p.height < newParent.width * newParent.height)) newParent = p;
                    }
                }
                currentBlock.parentId = (newParent && x >= newParent.x && x+width <= newParent.x+newParent.width && y >= newParent.y && y+height <= newParent.y+newParent.height) ? newParent.id : null;
             } else if ((dragging || resizing) && [...dragStartStates.keys()].some(b => hasOverlap(b, new Set(dragStartStates.keys())))) {
                dragStartStates.forEach((state, block) => Object.assign(block, state));
             }
            drawing = dragging = resizing = false; currentBlock = null; dragStartStates.clear();
            updateMarkdown(); draw();
        });
        
        canvas.addEventListener('dblclick', e => { const b = getTopBlockAtPos(getMousePos(e)); if(b) showTextEditor(b); });
        
        function showTextEditor(block) {
            editingBlock = block;
            Object.assign(textEditor.style, { display: 'block', left: `${block.x}px`, top: `${block.y}px`, width: `${block.width}px`, height: `${block.height}px` });
            textEditor.value = block.text.replace(/\\n/g, '\n'); textEditor.focus(); textEditor.select();
        }
        function hideTextEditor() {
            if (!editingBlock) return;
            editingBlock.text = textEditor.value.replace(/\n/g, '\\n');
            editingBlock = null; textEditor.style.display = 'none'; draw(); updateMarkdown();
        }
        textEditor.addEventListener('blur', hideTextEditor);
        textEditor.addEventListener('keydown', e => { if (e.key==='Enter' && !e.shiftKey) {e.preventDefault();hideTextEditor();} if(e.key==='Escape'){editingBlock=null;textEditor.style.display='none';draw();}});
        
        // --- CONTEXT MENU & ACTIONS ---
        function showContextMenu(x, y) {
            Object.assign(contextMenu.style, {left:`${x}px`, top:`${y}px`}); contextMenu.classList.add('show');
            const canMerge = selectedBlocks.size > 1; mergeBtn.disabled=!canMerge; Object.assign(mergeBtn.style, {cursor:canMerge?'pointer':'not-allowed',opacity:canMerge?1:0.5});
        }
        function hideContextMenu() { contextMenu.classList.remove('show'); activeContextMenuBlock = null; }
        window.addEventListener('click', e => { if (!contextMenu.contains(e.target)) hideContextMenu(); });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        const createAndAddBlock = (props) => { blocks.push({ id: generateFriendlyId(), parentId: activeContextMenuBlock.parentId, text: 'New Block', ...props }); hideContextMenu(); draw(); updateMarkdown(); };
        splitHBtn.addEventListener('click', () => { if(!activeContextMenuBlock) return; const h = snapToGrid(activeContextMenuBlock.height/2); createAndAddBlock({ ...activeContextMenuBlock, y: activeContextMenuBlock.y+h, height:activeContextMenuBlock.height-h}); activeContextMenuBlock.height = h; });
        splitVBtn.addEventListener('click', () => { if(!activeContextMenuBlock) return; const w = snapToGrid(activeContextMenuBlock.width/2); createAndAddBlock({ ...activeContextMenuBlock, x: activeContextMenuBlock.x+w, width:activeContextMenuBlock.width-w}); activeContextMenuBlock.width = w; });
        deleteBtn.addEventListener('click', () => { const toDelete = new Set(selectedBlocks.size > 0 ? [...selectedBlocks] : (activeContextMenuBlock ? [activeContextMenuBlock] : [])); if (toDelete.size > 0) deleteBlocks(toDelete); hideContextMenu(); draw(); updateMarkdown(); });
        mergeBtn.addEventListener('click', () => { if(selectedBlocks.size<=1) return; const arr=[...selectedBlocks], b = arr.reduce((a,c)=>({minX:Math.min(a.minX,c.x),minY:Math.min(a.minY,c.y),maxX:Math.max(a.maxX,c.x+c.width),maxY:Math.max(a.maxY,c.y+c.height)}),{minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity}); const txt = arr.map(c=>c.text).filter(t=>t&&t.trim()!=='New Block').join(' / '); blocks=blocks.filter(c=>!selectedBlocks.has(c)); const newBlock={id:generateFriendlyId(),parentId:arr[0].parentId,x:b.minX,y:b.minY,width:b.maxX-b.minX,height:b.maxY-b.minY,text:txt||'Merged'}; blocks.push(newBlock); selectedBlocks.clear(); selectedBlocks.add(newBlock); hideContextMenu(); draw(); updateMarkdown(); });
        
        // --- HEADER BUTTONS & MERMAID GENERATION ---
        copyMarkdownBtn.addEventListener('click', () => { markdownOutput.select(); document.execCommand('copy'); const t=copyMarkdownBtn.innerText; copyMarkdownBtn.innerText='Copied!'; setTimeout(()=>copyMarkdownBtn.innerText=t,2000);});
        clearCanvasBtn.addEventListener('click', () => { blocks=[]; selectedBlocks.clear(); diagramTitleInput.value=''; draw(); updateMarkdown(); });
    fitDiagramBtn.addEventListener('click', () => { scrollCanvasToFitBlocks(); });
        diagramTitleInput.addEventListener('input', updateMarkdown);

    // --- Persistence: save/load canvas state to localStorage ---
        const STORAGE_KEY = 'blockitecht.canvas.v1';

        function saveCanvasState() {
            try {
                if (!autosaveEnabled) return; // skip saving during initialization
                // Don't overwrite an existing saved diagram with an empty canvas/title
                if ((!blocks || blocks.length === 0) && !diagramTitleInput.value.trim()) return;
                // Create a JSON-safe snapshot of blocks (avoid storing object references in connections)
                const blocksSnapshot = blocks.map(b => {
                    const { id, x, y, width, height, text, parentId, blockWidth, originalId, color } = b;
                    const connections = (b.connections || []).map(c => ({ targetId: (c.target && c.target.id) || c.targetId || null, label: c.label || '' }));
                    return { id, x, y, width, height, text, parentId, blockWidth, originalId, color, connections };
                });
                const payload = { title: diagramTitleInput.value || '', blocks: blocksSnapshot };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
                // Log success for debugging in browser console
                console.log('Saved canvas state to localStorage (items:', blocksSnapshot.length, ')');
            } catch (e) { console.warn('Failed to save canvas state', e); }
        }

        function loadCanvasState() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return false;
                const parsed = JSON.parse(raw);
                if (parsed && Array.isArray(parsed.blocks)) {
                    // Ensure loaded blocks are snapped to grid (we already snap on manual load too)
                    const snapFloor = v => Math.floor(v / gridSize) * gridSize;
                    // Reconstruct blocks (plain objects) from snapshot
                    const reconstructed = parsed.blocks.map(b => {
                        return {
                            id: b.id,
                            x: typeof b.x === 'number' ? snapFloor(b.x) : 0,
                            y: typeof b.y === 'number' ? snapFloor(b.y) : 0,
                            width: typeof b.width === 'number' ? Math.max(gridSize, Math.floor(b.width / gridSize) * gridSize) : gridSize,
                            height: typeof b.height === 'number' ? Math.max(gridSize, Math.floor(b.height / gridSize) * gridSize) : gridSize,
                            text: b.text || b.id,
                            parentId: b.parentId || null,
                            blockWidth: b.blockWidth || (b.blockWidth === 0 ? 0 : 1),
                            originalId: b.originalId,
                            color: b.color || null
                        };
                    });

                    // Restore connections by resolving targetId to object references
                    const byId = new Map(reconstructed.map(b => [b.id, b]));
                    parsed.blocks.forEach((bSnapshot) => {
                        if (Array.isArray(bSnapshot.connections) && bSnapshot.connections.length > 0) {
                            const source = byId.get(bSnapshot.id);
                            if (!source) return;
                            source.connections = [];
                            for (const c of bSnapshot.connections) {
                                const target = byId.get(c.targetId) || null;
                                source.connections.push({ target: target, label: c.label || '' });
                            }
                        }
                    });

                    // Restore color property if present
                    parsed.blocks.forEach(bSnapshot => {
                        const target = byId.get(bSnapshot.id);
                        if (target && bSnapshot.color) target.color = bSnapshot.color;
                    });

                    blocks = reconstructed;
                    diagramTitleInput.value = parsed.title || '';
                    selectedBlocks.clear();
                    draw();
                    updateMarkdown();
                    // Scroll container to show the loaded diagram
                    scrollCanvasToFitBlocks();
                    console.log('Loaded canvas state from localStorage (items:', blocks.length, ')');
                    return true;
                }
            } catch (e) { console.warn('Failed to load canvas state', e); }
            return false;
        }

    // Clear stored state when clearing canvas
    clearCanvasBtn.addEventListener('click', () => { localStorage.removeItem(STORAGE_KEY); blocks = []; selectedBlocks.clear(); diagramTitleInput.value = ''; draw(); updateMarkdown(); });

        // Load any persisted state on startup and enable autosave afterwards
        document.addEventListener('DOMContentLoaded', () => {
            // Resize canvas now that DOM is ready
            resizeCanvas();
            const loaded = loadCanvasState();
            if (loaded) console.log('Loaded saved canvas state from localStorage');
            // Enable autosave after initial load so we don't overwrite stored state
            autosaveEnabled = true;
        });

        function updateMarkdown() {
            let title = diagramTitleInput.value.trim();
            let output = '';
            if (title) {
                output += `# ${title}\n\n`;
            }
            const topLevelBlocks = blocks.filter(b => !b.parentId);
            if (topLevelBlocks.length > 0) {
                output += generateMermaidBlockDiagram(topLevelBlocks);
            } else {
                output += 'block\ncolumns 3\n  %% Add blocks to the canvas to generate diagram';
            }
            markdownOutput.value = output;
            // Persist canvas state whenever the markdown/diagram is updated
            saveCanvasState();
        }

        // --- TEST HARNESS ---

        function deleteBlocks(startingBlocks) {
            const allToDelete = new Set();
            startingBlocks.forEach(b => getDescendants(b, blocks, true).forEach(d => allToDelete.add(d.id)));
            blocks = blocks.filter(b => !allToDelete.has(b.id));
            selectedBlocks = new Set([...selectedBlocks].filter(b => !allToDelete.has(b.id)));
        }
        window.addEventListener('keydown', (e) => { if ((e.key==='Delete'||e.key==='Backspace') && !['INPUT','TEXTAREA'].includes(document.activeElement.tagName) && selectedBlocks.size>0) { e.preventDefault(); deleteBlocks(selectedBlocks); draw(); updateMarkdown(); }});
        
        // AI features removed

        // --- LOAD MODAL LOGIC ---
        loadMarkdownBtn.addEventListener('click', () => { loadInput.value = ''; loadError.classList.add('hidden'); loadModal.classList.remove('hidden'); });
        closeLoadModalBtn.addEventListener('click', () => loadModal.classList.add('hidden'));

        function parseHtmlToBlocks(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const table = doc.querySelector('table');
            if (!table) return [];

            const parsedBlocks = [];
            const tempGrid = [];
            const rows = table.querySelectorAll(':scope > tbody > tr, :scope > tr');

            rows.forEach((row, r) => {
                if (!tempGrid[r]) tempGrid[r] = [];
                let currentC = 0;
                Array.from(row.children).forEach(cell => {
                    while (tempGrid[r][currentC]) { currentC++; }

                    const colspan = parseInt(cell.getAttribute('colspan') || '1');
                    const rowspan = parseInt(cell.getAttribute('rowspan') || '1');
                    const width = colspan * gridSize * 2;
                    const height = rowspan * gridSize * 2;
                    const x = currentC * gridSize * 2;
                    const y = r * gridSize * 2;
                    
                    const newBlock = { id: generateFriendlyId(), parentId: null, x, y, width, height, text: '' };

                    // Handle nested tables first, recursively
                    const nestedTable = cell.querySelector('table');
                    if (nestedTable) {
                        const children = parseHtmlToBlocks(nestedTable.outerHTML);
                        children.forEach(child => {
                            child.parentId = newBlock.id;
                            child.x += newBlock.x;
                            child.y += newBlock.y;
                        });
                        parsedBlocks.push(...children);
                        nestedTable.parentElement.removeChild(nestedTable); // Remove after parsing
                    }

                    // Extract text content from the cell (now without the nested table)
                    let cellText = (cell.innerHTML || "").replace(/<br\s*\/?>/gi, '\\n');
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = cellText;
                    newBlock.text = (tempDiv.textContent || "").trim();

                    parsedBlocks.push(newBlock);

                    for (let i = r; i < r + rowspan; i++) {
                        if (!tempGrid[i]) tempGrid[i] = [];
                        for (let j = currentC; j < currentC + colspan; j++) {
                            tempGrid[i][j] = newBlock;
                        }
                    }
                    currentC += colspan;
                });
            });

            return parsedBlocks; // Return all blocks, unfiltered
        }

        function parseBlockDiagramInput(input) {
            // Parse Mermaid block diagram syntax and create blocks
            
            // Extract title from block comment, title: line, or Markdown heading (lines starting with '#')
            const titleMatch = input.match(/^%%\s*(.*?)\s*%%/m) || input.match(/^title:\s*(.*?)$/m) || input.match(/^#\s*(.*?)$/m);
            const title = titleMatch ? titleMatch[1].trim() : '';
            
            // Extract columns directive
            const columnsMatch = input.match(/^columns\s+(\d+)\s*$/m);
            const columnCount = columnsMatch ? parseInt(columnsMatch[1]) : 3; // default to 3 columns
            
            // Remove comments, title, block, and columns lines for parsing
         const cleanInput = input
          .split('\n')
          .filter(line => !line.trim().match(/^%%/) && !line.trim().match(/^title:/) && !line.trim().match(/^#\s*/) &&
              !line.trim().match(/^block\s*$/) && !line.trim().match(/^columns\s+\d+\s*$/))
          .join('\n');
            
            // Parse block definitions and connections with nesting support
            const lines = cleanInput.split('\n');
            const blockMap = new Map();
            const connections = [];
            const parentStack = []; // Stack to track current parent context
            
            // Grid positioning based on column count
            let currentRow = 0;
            let currentCol = 0;
            const blockWidth = 120;
            const blockHeight = 80;
            const padding = 20;
            
            function calculatePosition(row, col) {
                const x = col * (blockWidth + padding) + 50;
                const y = row * (blockHeight + padding) + 50;
                return { x, y };
            }
            
            function createBlock(blockId, label, parentId = null, useGrid = true, widthFactor = 1) {
                // If block already exists, possibly update its blockWidth and return it
                if (blockMap.has(blockId)) {
                    const existing = blockMap.get(blockId);
                    if (widthFactor && (!existing.blockWidth || widthFactor > existing.blockWidth)) {
                        existing.blockWidth = widthFactor;
                    }
                    return existing;
                }

                let x, y, width = 100, height = 60;
                // Determine width factor: prefer explicit param, otherwise default to 1
                let blockWidthFactor = Math.max(1, widthFactor || 1);

                if (useGrid && !parentId) {
                    // Use grid positioning for top-level blocks
                    const pos = calculatePosition(currentRow, currentCol);
                    x = pos.x;
                    y = pos.y;
                    // Apply width factor to block pixel width
                    width = 100 * blockWidthFactor;

                    // Advance grid position by the width factor (span columns)
                    currentCol += blockWidthFactor;
                    while (currentCol >= columnCount) {
                        currentCol -= columnCount;
                        currentRow++;
                    }
                } else if (parentId) {
                    // Position child blocks inside parent with proper layout
                    const parent = blockMap.get(parentId);
                    if (parent) {
                        // Count existing children to determine position
                        const existingChildren = Array.from(blockMap.values()).filter(b => b.parentId === parentId);
                        const childIndex = existingChildren.length;
                        
                        // Layout children in a grid within the parent
                        const childPadding = 10;
                        const childWidth = 80;
                        const childHeight = 40;
                        const childrenPerRow = Math.max(1, Math.floor((parent.width - 2 * childPadding) / (childWidth + childPadding)));
                        
                        const childRow = Math.floor(childIndex / childrenPerRow);
                        const childCol = childIndex % childrenPerRow;
                        
                        x = parent.x + childPadding + childCol * (childWidth + childPadding);
                        y = parent.y + 30 + childRow * (childHeight + childPadding);
                        width = childWidth;
                        height = childHeight;
                        
                        // Ensure parent is large enough to contain all children
                        const requiredWidth = Math.max(120, 2 * childPadding + childrenPerRow * (childWidth + childPadding));
                        const requiredHeight = Math.max(80, 30 + (childRow + 1) * (childHeight + childPadding) + childPadding);
                        
                        parent.width = Math.max(parent.width, requiredWidth);
                        parent.height = Math.max(parent.height, requiredHeight);
                    } else {
                        // Fallback positioning
                        const pos = calculatePosition(currentRow, currentCol);
                        x = pos.x;
                        y = pos.y;
                    }
                } else {
                    // Fallback positioning
                    const pos = calculatePosition(currentRow, currentCol);
                    x = pos.x;
                    y = pos.y;
                }

                const block = {
                    id: blockId,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    text: label || blockId,
                    parentId: parentId,
                    blockWidth: blockWidthFactor
                };

                blockMap.set(blockId, block);
                return block;
            }
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                const indent = line.length - line.trimStart().length;
                
                if (!trimmed) continue;
                
                // Handle end keyword - pop from parent stack
                if (trimmed === 'end') {
                    parentStack.pop();
                    continue;
                }
                
                // Parse block:ID syntax - starts a new parent block (allow hyphens in IDs)
                // Allow optional label and color annotation after block:ID like `block:ID["Label"] %%color:93C5FD`
                const blockColonMatch = trimmed.match(/^block:([\w-]+)(?:\["([^\"]*)"\])?(?:\s+%%color:(#?[0-9A-Fa-f]{6}))?$/);
                if (blockColonMatch) {
                    const [, blockId, labelMatch, colorMatch] = blockColonMatch;
                    const currentParent = parentStack.length > 0 ? parentStack[parentStack.length - 1] : null;

                    // Create or fetch; if a label is explicitly provided use it, otherwise preserve any existing label
                    const block = createBlock(blockId, labelMatch || blockId, currentParent);
                    block.originalId = blockId;
                    if (labelMatch && labelMatch.trim()) {
                        block.text = labelMatch;
                    }
                    if (colorMatch) {
                        block.color = colorMatch.startsWith('#') ? colorMatch : '#' + colorMatch;
                    }

                    parentStack.push(blockId);
                    continue;
                }
                
                // If this line is a connection (e.g. "A --> B" or "A --> |"label"|B"), parse it
                // Use a small string-based parser instead of a complex regex literal to avoid
                // editor/HTML linter issues with escape sequences inside the <script>.
                const arrowIndex = trimmed.indexOf('-->');
                if (arrowIndex !== -1) {
                    const left = trimmed.slice(0, arrowIndex).trim();
                    let right = trimmed.slice(arrowIndex + 3).trim();
                    let fromId = left;
                    let toId = '';
                    let label = '';

                    // If the right side starts with |" then expect a label of the form |"..."| followed by the target id
                    if (right.startsWith('|"')) {
                        const endLabelIdx = right.indexOf('"|', 2);
                        if (endLabelIdx !== -1) {
                            label = right.slice(2, endLabelIdx);
                            toId = right.slice(endLabelIdx + 2).trim();
                        } else {
                            // malformed; treat whole right as toId fallback
                            toId = right;
                        }
                    } else {
                        // No inline label, right side should be the target id
                        toId = right.split(/\s+/)[0];
                    }

                    // Validate simple id shapes before accepting (allow hyphens for UUIDs)
                    if (/^[\w-]+$/.test(fromId) && /^[\w-]+$/.test(toId)) {
                        const currentParent = parentStack.length > 0 ? parentStack[parentStack.length - 1] : null;
                        // Ensure both blocks exist - don't advance grid for connection-implied blocks
                        createBlock(fromId, fromId, currentParent, false);
                        createBlock(toId, toId, currentParent, false);
                        connections.push({ from: fromId, to: toId, label: label || '' });
                        continue;
                    }
                    // fallthrough to token parsing if it wasn't a valid connection line
                }

                // Tokenize the trimmed line into block tokens or space tokens so we support multiple
                // definitions on the same line (e.g. `a["A label"] b:2 c:2 d`). This regex matches
                // either a space token or a block token (id, optional :width, optional ["label"]).
                // Tokenize block tokens; allow IDs containing letters, digits, underscore and hyphen
                const tokenRegex = /(?:space(?::\d+)?)|(?:[\w-]+(?::\d+)?(?:\["[^\"]*"\])?)/g;
                let match;
                const currentParent = parentStack.length > 0 ? parentStack[parentStack.length - 1] : null;
                while ((match = tokenRegex.exec(trimmed)) !== null) {
                    const token = match[0];
                    // If this token has an inline color annotation following it like '... %%color:#RRGGBB',
                    // try to capture that from the remaining substring after this token.
                    let color = null;
                    const after = trimmed.slice(tokenRegex.lastIndex);
                    const colorMatch = after.match(/^(?:\s*%%color:(#?[0-9A-Fa-f]{6}))/);
                    if (colorMatch) {
                        color = colorMatch[1].startsWith('#') ? colorMatch[1] : '#' + colorMatch[1];
                        // advance the regex index past the color annotation so it doesn't get reprocessed
                        tokenRegex.lastIndex += colorMatch[0].length;
                    }
                    if (/^space/.test(token)) {
                        const sm = token.match(/^space(?::(\d+))?$/);
                        const spaceWidth = sm && sm[1] ? parseInt(sm[1]) : 1;
                        currentCol += spaceWidth;
                        while (currentCol >= columnCount) {
                            currentCol -= columnCount;
                            currentRow++;
                        }
                        continue;
                    }

                    // Block token
                    // Allow hyphens in block id (UUIDs include hyphens)
                    const bm = token.match(/^([\w-]+)(?::(\d+))?(?:\["([^\"]+)"\])?$/);
                    if (bm) {
                        const [, blockId, widthStr, label] = bm;
                        const widthFactor = widthStr ? parseInt(widthStr) : 1;
                        const blk = createBlock(blockId, label, currentParent, true, widthFactor);
                        if (color) blk.color = color;
                    }
                }
            }
            
            // Convert Map to Array for the blocks
            const newBlocks = Array.from(blockMap.values());

            // Attach original diagram column count to parsed blocks so a generator
            // can prefer the original `columns N` directive during round-trip.
            newBlocks.forEach(b => { b._diagramColumns = columnCount; });
            
            // Add connections to blocks
            connections.forEach(conn => {
                const fromBlock = newBlocks.find(b => b.id === conn.from);
                const toBlock = newBlocks.find(b => b.id === conn.to);
                if (fromBlock && toBlock) {
                    if (!fromBlock.connections) fromBlock.connections = [];
                    fromBlock.connections.push({
                        target: toBlock,
                        label: conn.label
                    });
                }
            });
            
            return { title, blocks: newBlocks };
        }

        // --- Mermaid Generator ---
        function detectAndCreateVerticalSpans(topLevelBlocks) {
            // Only apply vertical span detection when there are at least 3 blocks
            // and there's evidence of a vertical spanning layout
            if (topLevelBlocks.length < 3) {
                return topLevelBlocks;
            }
            
            // Group blocks into columns based on X position (with tolerance)
            const columnTolerance = 50; // px tolerance for column alignment
            const rowTolerance = 20;    // px tolerance for row alignment
            
            // Sort blocks by X position to process columns left to right
            const sortedBlocks = topLevelBlocks.slice().sort((a, b) => a.x - b.x);
            const columns = [];
            
            // Group blocks into columns
            for (const block of sortedBlocks) {
                let placed = false;
                for (const col of columns) {
                    // Check if block overlaps horizontally with this column
                    const colLeft = Math.min(...col.blocks.map(b => b.x));
                    const colRight = Math.max(...col.blocks.map(b => b.x + b.width));
                    const blockLeft = block.x;
                    const blockRight = block.x + block.width;
                    
                    // Check for horizontal overlap with proper logic
                    // Two ranges overlap if: left1 < right2 AND left2 < right1
                    const overlaps = blockLeft < colRight && colLeft < blockRight;
                    
                    if (overlaps) {
                        col.blocks.push(block);
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    columns.push({ blocks: [block] });
                }
            }
            
            // Only proceed if we have exactly 2 columns (classic vertical span scenario)
            if (columns.length !== 2) {
                return topLevelBlocks;
            }
            
            // Process each column to detect vertical spans
            const resultBlocks = [];
            let invisibleParentCounter = 1;
            
            for (const column of columns) {
                if (column.blocks.length <= 1) {
                    // Single block column, check if it spans multiple row heights
                    if (column.blocks.length === 1) {
                        resultBlocks.push(column.blocks[0]);
                    }
                    continue;
                }
                
                // Sort blocks in column by Y position
                column.blocks.sort((a, b) => a.y - b.y);
                
                // Check if this column has blocks that could be grouped opposite a spanning block
                // Look for 2 or more blocks that are vertically stacked
                const avgBlockHeight = column.blocks.reduce((sum, b) => sum + b.height, 0) / column.blocks.length;
                
                // Check if the other column has a single tall block
                const otherColumn = columns.find(c => c !== column);
                const hasSpanningBlock = otherColumn && otherColumn.blocks.length === 1 && 
                                       otherColumn.blocks[0].height > avgBlockHeight * 1.5;
                
                if (hasSpanningBlock && column.blocks.length >= 2) {
                    // Create invisible parent for this column's blocks
                    const invisibleParentId = `InvisibleParent${invisibleParentCounter++}`;
                    const invisibleParent = {
                        id: invisibleParentId,
                        text: '', // Empty text makes it invisible
                        parentId: null,
                        x: Math.min(...column.blocks.map(b => b.x)),
                        y: Math.min(...column.blocks.map(b => b.y)),
                        width: Math.max(...column.blocks.map(b => b.x + b.width)) - Math.min(...column.blocks.map(b => b.x)),
                        height: Math.max(...column.blocks.map(b => b.y + b.height)) - Math.min(...column.blocks.map(b => b.y)),
                        _isInvisibleParent: true
                    };
                    
                    // Set parent relationship for all blocks in this column
                    column.blocks.forEach(block => {
                        block.parentId = invisibleParentId;
                    });
                    
                    // Add invisible parent to results
                    resultBlocks.push(invisibleParent);
                    // Column blocks are now children, they'll be handled by the recursive emission
                } else {
                    // No spanning layout detected, add all blocks as-is
                    resultBlocks.push(...column.blocks);
                }
            }
            
            return resultBlocks;
        }

        function generateMermaidBlockDiagram(blockList) {
            // Accept either a full block list or top-level blocks; normalize to a full list
            let allBlocks = [];
            if (Array.isArray(blockList)) {
                // If caller passed only top-level blocks (no parentId set), prefer the global `blocks`
                // which contains the full diagram so nested children are included.
                const looksLikeTopLevelOnly = blockList.length > 0 && blockList.every(b => !b.parentId);
                if (looksLikeTopLevelOnly && typeof blocks !== 'undefined' && Array.isArray(blocks) && blocks.length > 0) {
                    allBlocks = blocks.slice();
                } else {
                    allBlocks = blockList.slice();
                }
            }
            
            // Find top-level blocks (those with no parentId)
            let topLevel = allBlocks.filter(b => !b.parentId);

            // Detect vertical span layouts and create invisible parent blocks
            topLevel = detectAndCreateVerticalSpans(topLevel);
            
            // Update allBlocks to include any new invisible parent blocks
            const invisibleParents = topLevel.filter(b => b._isInvisibleParent);
            allBlocks = [...allBlocks, ...invisibleParents];
            
            const byId = new Map(allBlocks.map(b => [b.id, b]));

            // Infer unit pixel width for span inference when block.blockWidth is not set
            const pixelWidths = allBlocks.map(b => b.width || 0).filter(w => w > 0);
            const unit = pixelWidths.length > 0 ? Math.min(...pixelWidths) : 100;

            function spanFor(block) {
                if (block.blockWidth && Number.isFinite(block.blockWidth)) return Math.max(1, block.blockWidth);
                if (block.width && unit > 0) return Math.max(1, Math.round(block.width / unit));
                return 1;
            }

            function escapeLabel(s) {
                if (!s && s !== '') return '';
                return s.replace(/"/g, '\\"');
            }

            function emitBlockRecursive(b, indent = '  ') {
                const children = allBlocks.filter(x => x.parentId === b.id);
                const lines = [];
                if (children.length > 0) {
                    // Start parent block (emit label and color annotation if present)
                    const colorToken = b.color ? ` %%color:${b.color.replace('#','')}` : '';
                    
                    // For invisible parents, don't emit a label (empty text)
                    const label = (b.text && !b._isInvisibleParent) ? `["${escapeLabel(b.text)}"]` : '';
                    
                    lines.push(`${indent}block:${b.id}${label}${colorToken}`);
                    for (const child of children) {
                        lines.push(emitBlockRecursive(child, indent + '  '));
                    }
                    lines.push(`${indent}end`);
                } else {
                    const span = spanFor(b);
                    const label = b.text ? `["${escapeLabel(b.text)}"]` : '';
                    // Append color annotation if present using a comment-style token which is easy to parse
                    const colorToken = b.color ? ` %%color:${b.color.replace('#','')}` : '';
                    lines.push(`${indent}${b.id}${span > 1 ? `:${span}` : ''}${label}${colorToken}`);
                }
                return lines.join('\n');
            }

            // Build output
            // If parsed blocks included a `columns N` directive, prefer that value
            // for round-trip fidelity. Otherwise infer number of columns by grouping
            // top-level blocks into rows (y-coordinate buckets) and summing their
            // span (blockWidth) per row. Use the maximum row sum as columns.
            let columns = null;
            if (topLevel.length > 0 && typeof topLevel[0]._diagramColumns === 'number') {
                columns = Math.max(...topLevel.map(b => b._diagramColumns || 0));
            }

            if (!columns || columns <= 0) {
                const rowTolerance = 40; // px tolerance to group blocks into the same row
                const rows = [];
                for (const b of topLevel) {
                    let placed = false;
                    for (const r of rows) {
                        if (Math.abs(r.y - b.y) <= rowTolerance) {
                            r.blocks.push(b);
                            placed = true;
                            break;
                        }
                    }
                    if (!placed) rows.push({ y: b.y, blocks: [b] });
                }

                let maxRowSpan = 1;
                for (const r of rows) {
                    let rowSum = 0;
                    for (const b of r.blocks) rowSum += spanFor(b);
                    maxRowSpan = Math.max(maxRowSpan, rowSum);
                }

                columns = Math.max(1, Math.round(maxRowSpan));
            }

            const out = ['block', `columns ${columns}`];
            for (const t of topLevel) {
                out.push(emitBlockRecursive(t));
            }
            return out.join('\n') + '\n';
        }

        loadConfirmBtn.addEventListener('click', () => {
            const input = loadInput.value.trim();
            if (!input) {
                loadError.innerText = "Input cannot be empty.";
                loadError.classList.remove('hidden');
                return;
            }
            try {
                const { title, blocks: newBlocks } = parseBlockDiagramInput(input);
                // Snap loaded blocks to the app grid so they align to the squares
                // Snap down to nearest grid cell (floor) so blocks align without growing unexpectedly
                const snapFloor = v => Math.floor(v / gridSize) * gridSize;
                newBlocks.forEach(b => {
                    if (typeof b.x === 'number') b.x = snapFloor(b.x);
                    if (typeof b.y === 'number') b.y = snapFloor(b.y);
                    if (typeof b.width === 'number') b.width = Math.max(gridSize, Math.floor(b.width / gridSize) * gridSize);
                    if (typeof b.height === 'number') b.height = Math.max(gridSize, Math.floor(b.height / gridSize) * gridSize);
                });

                diagramTitleInput.value = title;
                blocks = newBlocks;
                selectedBlocks.clear();
                draw();
                updateMarkdown();
                // Scroll to fit newly loaded diagram so users can see all blocks
                scrollCanvasToFitBlocks();
                loadModal.classList.add('hidden');
            } catch (error) {
                console.error("Parsing error:", error);
                loadError.innerText = error.message;
                loadError.classList.remove('hidden');
            }
        });

        // Scroll the canvas container so the bounding box of blocks is centered in view
        function scrollCanvasToFitBlocks() {
            try {
                if (!blocks || blocks.length === 0) return;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const b of blocks) {
                    if (typeof b.x === 'number') minX = Math.min(minX, b.x);
                    if (typeof b.y === 'number') minY = Math.min(minY, b.y);
                    if (typeof b.x === 'number' && typeof b.width === 'number') maxX = Math.max(maxX, b.x + b.width);
                    if (typeof b.y === 'number' && typeof b.height === 'number') maxY = Math.max(maxY, b.y + b.height);
                }
                if (!isFinite(minX) || !isFinite(minY)) return;
                const boxWidth = Math.max(1, maxX - minX);
                const boxHeight = Math.max(1, maxY - minY);
                const centerX = minX + boxWidth / 2;
                const centerY = minY + boxHeight / 2;
                // Scroll container so centerX/centerY are centered in viewport
                const targetScrollLeft = Math.max(0, Math.floor(centerX - canvasContainer.clientWidth / 2));
                const targetScrollTop = Math.max(0, Math.floor(centerY - canvasContainer.clientHeight / 2));
                canvasContainer.scrollLeft = targetScrollLeft;
                canvasContainer.scrollTop = targetScrollTop;
            } catch (e) { /* ignore */ }
        }


        // --- TEST HARNESS ---
        function runRoundTripTest() {
            console.log('ðŸ§ª Starting Round-Trip Test...');
            
            // Test cases
            const testCases = [
                {
                    name: 'Simple blocks',
                    input: `block
columns 3
  A["Frontend"]
  B["Backend"]
  C["Database"]`
                },
                {
                    name: 'Two column layout',
                    input: `block
columns 2
  A["Top Left"]
  B["Top Right"]
  C["Bottom Left"]
  D["Bottom Right"]`
                },
                {
                    name: 'Nested blocks with multiple children',
                    input: `block
columns 1
  block:block1
    block2["Inner 1"]
    block3["Inner 2"]
  end`
                },
                {
                    name: 'Nested blocks (original test)',
                    input: `block
columns 1
  D
  block:ID
    A
    B["A wide one in the middle"]
    C
  end`
                },
                {
                    name: 'Layout with spaces',
                    input: `block
columns 3
  A["Left"]
  space
  C["Right"]
  space
  B["Center"]
  space`
                },
                {
                    name: 'Blocks with connections',
                    input: `block
columns 2
  Frontend
  Backend
  Frontend --> Backend`
                }
            ];
            
            testCases.forEach((testCase, index) => {
                console.log(`\n--- Test ${index + 1}: ${testCase.name} ---`);
                console.log('Input:', testCase.input);
                
                try {
                    // Step 1: Parse input into blocks
                    const { title, blocks: parsedBlocks } = parseBlockDiagramInput(testCase.input);
                    console.log('âœ… Parsing successful');
                    console.log('Parsed blocks with positions:');
                    parsedBlocks.forEach(b => {
                        console.log(`  - ${b.id}: "${b.text}" at (${b.x}, ${b.y}) parent: ${b.parentId || 'none'}`);
                    });
                    
                    // Step 2: Simulate the blocks being loaded
                    const originalBlocks = [...blocks];
                    blocks = parsedBlocks;
                    
                    // Step 3: Generate output from those blocks
                    const output = generateMermaidBlockDiagram(parsedBlocks);
                    console.log('Generated output:', output);
                    
                    // Step 4: Parse the generated output back
                    const { blocks: reparsedBlocks } = parseBlockDiagramInput(output);
                    console.log('âœ… Re-parsing successful, blocks:', reparsedBlocks.map(b => ({ id: b.id, text: b.text, parentId: b.parentId })));
                    
                    // Step 5: Compare structures
                    const originalStructure = parsedBlocks.map(b => ({ id: b.id, text: b.text, parentId: b.parentId }));
                    const reparsedStructure = reparsedBlocks.map(b => ({ id: b.id, text: b.text, parentId: b.parentId }));
                    
                    const structuresMatch = JSON.stringify(originalStructure.sort((a,b) => a.id.localeCompare(b.id))) === 
                                          JSON.stringify(reparsedStructure.sort((a,b) => a.id.localeCompare(b.id)));
                    
                    if (structuresMatch) {
                        console.log('âœ… Round-trip successful!');
                    } else {
                        console.log('âŒ Round-trip failed - structures differ');
                        console.log('Original:', originalStructure);
                        console.log('Reparsed:', reparsedStructure);
                    }
                    
                    // Restore original blocks
                    blocks = originalBlocks;
                    
                } catch (error) {
                    console.error('âŒ Test failed:', error);
                    blocks = originalBlocks;
                }
            });
            
            console.log('\nðŸ Round-trip tests completed!');
        }
        
        // Add test button to UI (temporary)
        document.addEventListener('DOMContentLoaded', () => {
            const testBtn = document.createElement('button');
            testBtn.innerText = 'ðŸ§ª Run Tests';
            testBtn.style.cssText = 'position: fixed; top: 10px; right: 10px; z-index: 1000; padding: 5px 10px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer;';
            testBtn.onclick = () => {
                console.clear();
                runRoundTripTest();
                alert('Test results in console (F12)');
            };
            document.body.appendChild(testBtn);
        });

    // --- INITIALIZATION ---
    window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>




